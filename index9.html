<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç„¡é‚Šéš›å¹³é¢èˆ‡é¸å–®</title>
    <style>
        /* ç¢ºä¿ HTML å’Œ BODY ä½”æ»¿æ•´å€‹è¦–çª—ç©ºé–“ */
        html, body {
            height: 100%; 
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; 
        }
        
        /* ç¢ºä¿ Canvas ä½”æ»¿æ•´å€‹ body ç©ºé–“ */
        #infiniteCanvas {
            display: block;
            height: 100%; 
            width: 100%;  
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
        
        /* é‡æ–°é–‹å§‹æŒ‰éˆ•æ¨£å¼ */
        #restartButton {
            position: fixed; 
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        #restartButton:hover {
            background-color: #0056b3;
        }

        /* åœ‹å®¶é¸å–®æ¨£å¼ */
        #countryMenu {
            position: fixed; /* ä¿æŒé¸å–®å›ºå®šåœ¨è¢å¹•ä¸Šï¼Œä¸éš¨ç•«å¸ƒç§»å‹• */
            display: none; /* é è¨­éš±è— */
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 20; /* ç¢ºä¿åœ¨æŒ‰éˆ•å’Œç•«å¸ƒä¹‹ä¸Š */
            min-width: 150px;
            padding: 5px 0;
        }
        #menuHeader {
            padding: 8px 15px;
            font-weight: bold;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
            color: #333;
        }
        .menuItem {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .menuItem:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>
    <button id="restartButton">ğŸ”„ é‡æ–°é–‹å§‹</button>

    <div id="countryMenu">
        <div id="menuHeader"></div>
        <div class="menuItem" onclick="alert('é¡¯ç¤ºåœ‹å®¶æƒ…æ³è©³ç´°ä¿¡æ¯'); hideMenu();">åœ‹å®¶æƒ…æ³</div>
        </div>

    <script>
        // ----------------------------------------------------
        // ä¸»è¦è®Šæ•¸
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');
        const restartButton = document.getElementById('restartButton');
        const countryMenu = document.getElementById('countryMenu');
        const menuHeader = document.getElementById('menuHeader');

        // ç•«å¸ƒçš„ç‹€æ…‹
        let panX = 0; 
        let panY = 0; 
        let scale = 1.0; 
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; 

        // äº’å‹•ç‹€æ…‹è®Šæ•¸
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // è§¸æ§å°ˆç”¨è®Šæ•¸
        let isPinching = false;
        let lastTouchDistance = null; 
        let touchCenter = { x: 0, y: 0 }; 

        // ç¶²æ ¼è¨­å®š
        const BASE_GRID_SIZE = 50; 
        const INITIAL_COLORS = ["#007BFF", "#DC3545", "#FFC107"];
        const INITIAL_NAMES = ["åœ‹å®¶ A", "åœ‹å®¶ B", "åœ‹å®¶ C"];
        
        // åœ‹å®¶æ•¸æ“š (å‹•æ…‹ç”Ÿæˆ)
        let countries = []; 
        const MIN_AREA_SIZE = 150; 
        const MAX_AREA_SIZE = 300; 
        const WORLD_BOUNDARY = 800; 
        const MIN_DISTANCE_SQUARED = Math.pow(MIN_AREA_SIZE * 1.5, 2); 
        
        // ----------------------------------------------------
        // é¸å–®é‚è¼¯
        // ----------------------------------------------------

        /**
         * é¡¯ç¤ºé¸å–®
         * @param {number} x - è¢å¹•Xåº§æ¨™
         * @param {number} y - è¢å¹•Yåº§æ¨™
         * @param {string} countryName - è¢«é»æ“Šçš„åœ‹å®¶åç¨±
         */
        function showMenu(x, y, countryName) {
            menuHeader.textContent = countryName;
            countryMenu.style.left = `${x}px`;
            countryMenu.style.top = `${y}px`;
            countryMenu.style.display = 'block';
        }

        /**
         * éš±è—é¸å–®
         */
        function hideMenu() {
            countryMenu.style.display = 'none';
        }
        
        // é»æ“Šç•«å¸ƒä»»ä½•åœ°æ–¹ï¼Œå¦‚æœæ²’é»ä¸­åœ‹å®¶ï¼Œå°±éš±è—é¸å–®
        canvas.addEventListener('click', () => {
             // é»æ“Šäº‹ä»¶æœƒé€é checkCountryClick è™•ç†
        });
        
        // é»æ“Šç•«å¸ƒä»¥å¤–çš„åœ°æ–¹ä¹Ÿæ‡‰éš±è—é¸å–®
        window.addEventListener('mousedown', (e) => {
            if (e.target.id !== 'infiniteCanvas' && e.target.closest('#countryMenu') === null && e.target.id !== 'restartButton') {
                hideMenu();
            }
        });
        window.addEventListener('touchstart', (e) => {
             if (e.touches.length === 1 && e.target.id !== 'infiniteCanvas' && e.target.closest('#countryMenu') === null && e.target.id !== 'restartButton') {
                hideMenu();
            }
        });

        // ----------------------------------------------------
        // é»æ“Šæª¢æ¸¬ (Hit Testing)
        // ----------------------------------------------------

        /**
         * å°‡è¢å¹•åº§æ¨™è½‰æ›ç‚ºä¸–ç•Œåº§æ¨™
         * @param {number} clientX - è¢å¹•Xåº§æ¨™
         * @param {number} clientY - è¢å¹•Yåº§æ¨™
         * @returns {object} {worldX, worldY}
         */
        function screenToWorld(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;
            
            // é€†è½‰è®Šæ›çŸ©é™£ï¼š (è¢å¹•åº§æ¨™ - ç•«å¸ƒä¸­å¿ƒ) / ç¸®æ”¾ - å¹³ç§»åç§»
            const worldX = (canvasX - canvas.width / 2) / scale - panX;
            const worldY = (canvasY - canvas.height / 2) / scale - panY;
            
            return { worldX, worldY };
        }

        /**
         * æª¢æŸ¥é»æ“Šæ˜¯å¦è½åœ¨äº†æŸå€‹åœ‹å®¶å€åŸŸå…§
         * @param {number} clientX - è¢å¹•Xåº§æ¨™
         * @param {number} clientY - è¢å¹•Yåº§æ¨™
         * @returns {object | null} - è¢«é»æ“Šçš„åœ‹å®¶ç‰©ä»¶ï¼Œæˆ– null
         */
        function checkCountryClick(clientX, clientY) {
            // ç”±æ–¼ç¹ªåœ–è·¯å¾‘æ˜¯æš«æ™‚çš„ï¼Œæˆ‘å€‘éœ€è¦é‡æ–°ç¹ªè£½ä¸€æ¬¡è·¯å¾‘ä¾†ä½¿ç”¨ isPointInPath
            
            const { worldX, worldY } = screenToWorld(clientX, clientY);
            let clickedCountry = null;

            // åœ¨ç¹ªåœ–è®Šæ›ä¹‹å‰ä¿å­˜ç‹€æ…‹
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡è¨­è®Šæ›çŸ©é™£

            // æ‡‰ç”¨è®Šæ›çŸ©é™£ï¼Œèˆ‡ draw å‡½æ•¸ä¸­çš„ä¸€è‡´
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            // éæ­·æ‰€æœ‰åœ‹å®¶é€²è¡Œæª¢æ¸¬
            for (const country of countries) {
                const shape = country.curves;
                
                ctx.beginPath();
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                
                shape.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                
                ctx.closePath();
                
                // æª¢æŸ¥ä¸–ç•Œåº§æ¨™é»æ˜¯å¦åœ¨ç•¶å‰è·¯å¾‘å…§
                if (ctx.isPointInPath(worldX, worldY)) {
                    clickedCountry = country;
                    break; 
                }
            }

            ctx.restore(); // æ¢å¾©è®Šæ›ç‹€æ…‹

            return clickedCountry;
        }

        // ----------------------------------------------------
        // äº’å‹•é‚è¼¯ (å¢åŠ é»æ“Šæª¢æ¸¬)
        // ----------------------------------------------------
        
        let clickStart = {x: 0, y: 0}; // ç”¨æ–¼åˆ¤æ–·æ˜¯æ‹–æ›³é‚„æ˜¯å–®æ“Š

        // æ»‘é¼ /è§¸æ§é–‹å§‹æ™‚ï¼Œè¨˜éŒ„ä½ç½®
        function handleStart(clientX, clientY) {
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            clickStart = {x: clientX, y: clientY}; // è¨˜éŒ„é»æ“Šèµ·å§‹é»
            canvas.classList.add('grabbing');
        }

        // æ»‘é¼ /è§¸æ§çµæŸæ™‚ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºå–®æ“Š
        window.addEventListener('mouseup', (e) => {
            if (isDragging && !isPinching) {
                // æª¢æŸ¥æ˜¯å¦æ˜¯å–®æ“Š (ç§»å‹•è·é›¢æ¥µå°)
                const distance = Math.sqrt(
                    Math.pow(e.clientX - clickStart.x, 2) + 
                    Math.pow(e.clientY - clickStart.y, 2)
                );
                
                if (distance < 5) { // å…è¨± 5 åƒç´ çš„èª¤å·®
                    const country = checkCountryClick(e.clientX, e.clientY);
                    if (country) {
                        showMenu(e.clientX, e.clientY, country.name);
                    } else {
                        hideMenu();
                    }
                } else {
                    hideMenu();
                }
            }
            handleEnd();
        });
        
        // è§¸æ§çµæŸæ™‚ï¼Œæª¢æŸ¥æ˜¯å¦ç‚ºå–®æ“Š (é€™è£¡åƒ…è™•ç† touchend, touchmove é˜»æ­¢äº†å–®æ“Š)
        window.addEventListener('touchend', (e) => {
            if (e.touches.length === 0 && !isPinching) {
                const distance = Math.sqrt(
                    Math.pow(lastX - clickStart.x, 2) + 
                    Math.pow(lastY - clickStart.y, 2)
                );
                
                if (distance < 5) { 
                    // è§¸æ§çš„å–®æ“Šä½ç½®ä½¿ç”¨æœ€è¿‘ä¸€æ¬¡çš„ lastX/lastY
                    const country = checkCountryClick(lastX, lastY);
                    if (country) {
                        showMenu(lastX, lastY, country.name);
                    } else {
                        hideMenu();
                    }
                } else {
                    hideMenu();
                }
            }
            
            if (e.touches.length === 0) {
                handleEnd();
            } else if (e.touches.length === 1) {
                isPinching = false;
                lastTouchDistance = null;
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        });


        // ... (å…¶ä»–äº’å‹•å‡½æ•¸ï¼Œå¦‚ move, zoom, grid, country ç¹ªè£½å‡½æ•¸èˆ‡å‰æ¬¡ç‰ˆæœ¬ç›¸åŒï¼Œä½†ç‚ºç°¡æ½”çœç•¥äº†é‡è¤‡è¨»é‡‹) ...

        // ----------------------------------------------------
        // å¹¾ä½•èˆ‡ç”Ÿæˆå‡½æ•¸
        // ----------------------------------------------------

        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        function generateRandomCurveShape(centerX, centerY, size) {
            const NUM_POINTS = 6; 
            const shapeData = {
                startPoint: {x: 0, y: 0},
                curves: []
            };
            
            let currentX = centerX + size * Math.cos(0);
            let currentY = centerY + size * Math.sin(0);
            shapeData.startPoint = {x: currentX, y: currentY};

            for (let i = 0; i < NUM_POINTS; i++) {
                const angle3 = (i + 1) * (Math.PI * 2 / NUM_POINTS);
                
                const endX = centerX + size * getRandom(0.8, 1.2) * Math.cos(angle3);
                const endY = centerY + size * getRandom(0.8, 1.2) * Math.sin(angle3);
                
                const cp1X = currentX + (endX - currentX) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                const cp1Y = currentY + (endY - currentY) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                
                const cp2X = currentX + (endX - currentX) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);
                const cp2Y = currentY + (endY - currentY) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);

                shapeData.curves.push([
                    {x: cp1X, y: cp1Y}, 
                    {x: cp2X, y: cp2Y}, 
                    {x: endX, y: endY}
                ]);
                
                currentX = endX;
                currentY = endY;
            }
            
            shapeData.curves[NUM_POINTS - 1][2] = shapeData.startPoint; 

            return shapeData;
        }


        function generateNewCountries() {
            countries = [];
            const newCountryData = [];
            
            for (let i = 0; i < INITIAL_COLORS.length; i++) {
                let safeLocationFound = false;
                let attempts = 0;
                
                while (!safeLocationFound && attempts < 100) {
                    attempts++;

                    const centerX = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const centerY = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const size = getRandom(MIN_AREA_SIZE, MAX_AREA_SIZE); 
                    
                    let overlaps = false;
                    
                    for (const existingCountry of newCountryData) {
                        const dx = centerX - existingCountry.center.x;
                        const dy = centerY - existingCountry.center.y;
                        const distanceSquared = dx * dx + dy * dy;
                        
                        if (distanceSquared < MIN_DISTANCE_SQUARED) {
                            overlaps = true;
                            break;
                        }
                    }
                    
                    if (!overlaps) {
                        const shape = generateRandomCurveShape(centerX, centerY, size * 0.5); 

                        newCountryData.push({
                            name: INITIAL_NAMES[i],
                            color: INITIAL_COLORS[i],
                            center: {x: centerX, y: centerY},
                            ...shape,
                            size: size 
                        });
                        safeLocationFound = true;
                    }
                }
            }
            countries = newCountryData;
            draw();
        }
        
        // ----------------------------------------------------
        // åˆå§‹åŒ–èˆ‡äº‹ä»¶ç›£è½
        // ----------------------------------------------------

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        
        restartButton.addEventListener('click', () => {
            panX = 0;
            panY = 0;
            scale = 1.0;
            hideMenu(); // é»æ“Šé‡è¨­æ™‚éš±è—é¸å–®
            generateNewCountries();
        });
        
        resizeCanvas(); 
        generateNewCountries(); 

        
        // ----------------------------------------------------
        // äº’å‹•é‚è¼¯ (ç°¡åŒ–é‡è¤‡ç¨‹å¼ç¢¼ï¼Œåƒ…ä¿ç•™å¿…è¦çš„)
        // ----------------------------------------------------
        
        function getDistance(touch1, touch2) {
            return Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) + 
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
        }
        
        function performZoom(clientX, clientY, newScale) {
            newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;

            scale = newScale;

            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;

            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);
            
            draw();
        }
        
        function handleMove(clientX, clientY) {
            if (!isDragging || isPinching) return; 

            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            panX += deltaX / scale;
            panY += deltaY / scale;
            lastX = clientX;
            lastY = clientY;
            draw();
        }

        function handleEnd() {
            isDragging = false;
            isPinching = false;
            lastTouchDistance = null;
            canvas.classList.remove('grabbing');
        }
        
        // æ»‘é¼ /è§¸æ§é–‹å§‹äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => {
            hideMenu(); // é–‹å§‹æ‹–æ›³æˆ–é»æ“Šæ™‚éš±è—é¸å–®
            handleStart(e.clientX, e.clientY);
        });
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));

        // æ»¾è¼ªç¸®æ”¾
        canvas.addEventListener('wheel', (e) => {
            hideMenu(); // æ»¾è¼ªæ™‚éš±è—é¸å–®
            e.preventDefault(); 
            const delta = e.deltaY * -ZOOM_SPEED * 10; 
            const newScale = scale * (1 + delta);
            performZoom(e.clientX, e.clientY, newScale);
        });
        
        // è§¸æ§äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => {
            hideMenu(); // è§¸æ§æ™‚éš±è—é¸å–®
            e.preventDefault(); 
            
            if (e.touches.length === 1) {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                isPinching = true;
                handleEnd(); 
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                lastTouchDistance = getDistance(t1, t2);
                touchCenter.x = (t1.clientX + t2.clientX) / 2;
                touchCenter.y = (t1.clientY + t2.clientY) / 2;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1 && !isPinching) {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                isPinching = true;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                const currentDistance = getDistance(t1, t2);
                const deltaDistance = currentDistance - lastTouchDistance;
                
                touchCenter.x = (t1.clientX + t2.clientX) / 2;
                touchCenter.y = (t1.clientY + t2.clientY) / 2;
                
                const scaleFactor = deltaDistance * 0.005; 
                const newScale = scale + (scale * scaleFactor);

                performZoom(touchCenter.x, touchCenter.y, newScale);

                lastTouchDistance = currentDistance; 
            }
        });

        window.addEventListener('touchcancel', handleEnd); 

        // ----------------------------------------------------
        // ç¹ªåœ–é‚è¼¯
        // ----------------------------------------------------

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            drawGrid();
            drawCountries(); 

            ctx.restore();
        }

        function drawCountries() {
            countries.forEach(country => {
                ctx.fillStyle = country.color;
                
                // è¨»ï¼šé€™è£¡åªç¹ªè£½ï¼Œä¸é€²è¡Œè·¯å¾‘å„²å­˜ï¼Œè·¯å¾‘æª¢æ¸¬åœ¨ checkCountryClick ç¨ç«‹é€²è¡Œ
                ctx.beginPath(); 
                
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                
                country.curves.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3 / scale; 
                ctx.stroke();

                
                ctx.font = `${20 / scale}px Arial`;
                ctx.fillStyle = (country.color === "#FFC107") ? "#000000" : "#ffffff"; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillText(country.name, country.center.x, country.center.y);
            });
        }


        function drawGrid() {
            let gridSize = BASE_GRID_SIZE;
            
            while (gridSize * scale < 20) {
                gridSize *= 5; 
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; 
            }

            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; 

            ctx.beginPath();

            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
    </script>
</body>
</html>
