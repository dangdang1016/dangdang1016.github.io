<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 地面拖曳與空間旋轉 (含軸向控制器)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
        // --- 1. 場景初始化 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 設置光線
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // --- 2. 創建地面 (BoxGeometry 帶厚度) ---
        const groundWidth = 100;
        const groundHeight = 0.5; // 地面的厚度
        const groundDepth = 100;
        
        const groundGeometry = new THREE.BoxGeometry(groundWidth, groundHeight, groundDepth);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.name = 'Ground';
        scene.add(ground);

        // 初始化相機位置
        camera.position.set(20, 10, 20);

        // --- 3. 設置控制器 ---
        
        // A. 空間旋轉控制器 (OrbitControls)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true; 
        
        // B. 變換控制器 (TransformControls) - 核心功能
        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setMode('translate'); // 預設為移動 (三個軸向箭頭)
        transformControls.attach(ground); // 預設先綁定地面
        scene.add(transformControls);
        
        // 隱藏變換控制器，直到我們點擊它
        transformControls.visible = false;
        transformControls.enabled = false;
        
        // 監聽 TransformControls 的變化事件，確保 OrbitControls 知道它被使用
        transformControls.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value; // 當 TransformControls 開始拖曳時，禁用 OrbitControls
            // 此外，限制地面只能在 XZ 平面上移動（除非我們明確要允許 Y 軸移動）
            if (event.value) {
                // 如果開始拖曳，限制 Y 軸移動
                transformControls.showY = false;
            } else {
                // 如果結束拖曳，恢復 Y 軸顯示，但由於我們設置了 setMode('translate')，它會保持 XZ 顯示
                transformControls.showY = true;
            }
        });
        
        // 由於我們只希望地面在 XZ 平面移動，我們可以限制 Y 軸的控制
        transformControls.showY = false;


        // --- 4. 點擊選中邏輯 ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // 處理滑鼠/手指按下事件
        function onPointerDown(event) {
            // 如果 TransformControls 已經被啟用，並且我們點擊了它的軸，則跳過以下邏輯
            if (transformControls.dragging) return;
            
            // 獲取標準化裝置坐標
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // 檢查是否點擊到地面
            const intersects = raycaster.intersectObjects([ground]);

            if (intersects.length > 0 && intersects[0].object.name === 'Ground') {
                // 點擊到地面
                
                // 啟用並顯示軸向控制器
                transformControls.visible = true;
                transformControls.enabled = true;
                
                // 禁用空間旋轉控制，讓軸向控制工具工作
                controls.enabled = false; 

                // 為了避免點擊後控制器立即開始拖曳，我們在 TransformControls 的 'dragging-changed' 事件中處理控制器的啟用/禁用。
                
            } else {
                // 沒有點擊到地面
                
                // 隱藏並禁用軸向控制器
                transformControls.visible = false;
                transformControls.enabled = false;
                
                // 啟用空間旋轉控制
                controls.enabled = true;
            }
        }

        // 這裡我們不再需要 `onPointerMove` 和 `onPointerUp` 來手動拖曳地面，
        // 因為所有的拖曳動作都由 `THREE.TransformControls` 內部處理了！

        // 監聽事件
        renderer.domElement.addEventListener('pointerdown', onPointerDown);

        // --- 5. 渲染迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); // 更新 OrbitControls 阻尼
            transformControls.update(); // 更新 TransformControls 的位置和大小
            renderer.render(scene, camera);
        }

        animate();

        // --- 6. 響應式調整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
