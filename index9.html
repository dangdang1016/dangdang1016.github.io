<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç„¡é‚Šéš›å¹³é¢èˆ‡é‡è¨­æŒ‰éˆ•</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; 
        }
        #infiniteCanvas {
            display: block;
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
        /* é‡æ–°é–‹å§‹æŒ‰éˆ•çš„æ¨£å¼ï¼šå›ºå®šåœ¨å·¦ä¸Šè§’ï¼Œä¸éš¨æ‹–æ›³ç§»å‹• */
        #restartButton {
            position: fixed; /* é—œéµï¼šå›ºå®šå®šä½ï¼Œä¸éš¨ç•«å¸ƒæ²å‹•æˆ–æ‹–æ›³ */
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10; /* ç¢ºä¿æŒ‰éˆ•åœ¨ç•«å¸ƒä¹‹ä¸Š */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        #restartButton:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>
    <button id="restartButton">ğŸ”„ é‡æ–°é–‹å§‹</button>

    <script>
        // ----------------------------------------------------
        // ä¸»è¦è®Šæ•¸
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');
        const restartButton = document.getElementById('restartButton');

        // ç•«å¸ƒçš„ç‹€æ…‹
        let panX = 0; 
        let panY = 0; 
        let scale = 1.0; 
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; 

        // äº’å‹•ç‹€æ…‹è®Šæ•¸
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // è§¸æ§å°ˆç”¨è®Šæ•¸
        let isPinching = false;
        let lastTouchDistance = null; 
        let touchCenter = { x: 0, y: 0 }; 

        // ç¶²æ ¼è¨­å®š
        const BASE_GRID_SIZE = 50; 
        const INITIAL_COLORS = ["#007BFF", "#DC3545", "#FFC107"];
        const INITIAL_NAMES = ["åœ‹å®¶ A", "åœ‹å®¶ B", "åœ‹å®¶ C"];
        
        // åœ‹å®¶æ•¸æ“š (å‹•æ…‹ç”Ÿæˆ)
        let countries = []; 
        const MIN_AREA_SIZE = 150; // åœ‹å®¶å€åŸŸçš„æœ€å°é‚Šç•Œé•·åº¦
        const MAX_AREA_SIZE = 300; // åœ‹å®¶å€åŸŸçš„æœ€å¤§é‚Šç•Œé•·åº¦
        const WORLD_BOUNDARY = 800; // ä¸–ç•Œåº§æ¨™ä¸­ï¼Œåœ‹å®¶ä¸­å¿ƒé»çš„æœ€å¤§çµ•å°å€¼
        const MIN_DISTANCE_SQUARED = Math.pow(MIN_AREA_SIZE, 2); // æœ€å°è·é›¢å¹³æ–¹ï¼Œç”¨æ–¼ç¢°æ’æª¢æ¸¬
        
        // ----------------------------------------------------
        // å¹¾ä½•èˆ‡ç”Ÿæˆå‡½æ•¸
        // ----------------------------------------------------

        /**
         * ç”¢ç”ŸæŒ‡å®šç¯„åœå…§çš„éš¨æ©Ÿæ•´æ•¸
         */
        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        /**
         * ç”¢ç”Ÿä¸€å€‹åœ‹å®¶å€åŸŸçš„éš¨æ©Ÿæ›²ç·šå½¢ç‹€
         * @param {number} centerX - ä¸­å¿ƒé»Xåº§æ¨™
         * @param {number} centerY - ä¸­å¿ƒé»Yåº§æ¨™
         * @param {number} size - å½¢ç‹€å¤§è‡´çš„åŠå¾‘/å¤§å°
         * @returns {object} {startPoint, curves}
         */
        function generateRandomCurveShape(centerX, centerY, size) {
            // ç°¡åŒ–ï¼šä½¿ç”¨ 6 å€‹éŒ¨é»ï¼Œæ¯å…©å€‹éŒ¨é»é–“æœ‰ä¸€æ®µè²èŒ²æ›²ç·š
            const NUM_POINTS = 6; 
            const shapeData = {
                startPoint: {x: 0, y: 0},
                curves: []
            };
            
            let currentX = centerX + size * Math.cos(0);
            let currentY = centerY + size * Math.sin(0);
            shapeData.startPoint = {x: currentX, y: currentY};

            for (let i = 0; i < NUM_POINTS; i++) {
                const angle1 = i * (Math.PI * 2 / NUM_POINTS);
                const angle2 = (i + 0.5) * (Math.PI * 2 / NUM_POINTS);
                const angle3 = (i + 1) * (Math.PI * 2 / NUM_POINTS);
                
                // çµæŸé» (ä¸‹ä¸€å€‹éŒ¨é»)
                const endX = centerX + size * getRandom(0.8, 1.2) * Math.cos(angle3);
                const endY = centerY + size * getRandom(0.8, 1.2) * Math.sin(angle3);
                
                // æ§åˆ¶é» 1: åœ¨ç•¶å‰éŒ¨é»å’Œä¸‹ä¸€å€‹éŒ¨é»ä¹‹é–“
                const cp1X = currentX + (endX - currentX) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                const cp1Y = currentY + (endY - currentY) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                
                // æ§åˆ¶é» 2: åœ¨ä¸‹ä¸€å€‹éŒ¨é»é™„è¿‘
                const cp2X = currentX + (endX - currentX) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);
                const cp2Y = currentY + (endY - currentY) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);

                shapeData.curves.push([
                    {x: cp1X, y: cp1Y}, 
                    {x: cp2X, y: cp2Y}, 
                    {x: endX, y: endY}
                ]);
                
                currentX = endX;
                currentY = endY;
            }
            
            // ä¿®æ­£æœ€å¾Œä¸€å€‹æ›²ç·šçš„çµæŸé»ï¼Œå¼·åˆ¶å›åˆ°èµ·å§‹é»é–‰åˆ
            shapeData.curves[NUM_POINTS - 1][2] = shapeData.startPoint; 

            return shapeData;
        }


        /**
         * éš¨æ©Ÿç”Ÿæˆæ‰€æœ‰åœ‹å®¶çš„æ•¸æ“šï¼Œä¸¦ç¢ºä¿å®ƒå€‘ä¸é‡ç–Š
         */
        function generateNewCountries() {
            countries = [];
            const newCountryData = [];
            
            for (let i = 0; i < INITIAL_COLORS.length; i++) {
                let safeLocationFound = false;
                let attempts = 0;
                
                while (!safeLocationFound && attempts < 100) {
                    attempts++;

                    // 1. éš¨æ©Ÿé¸æ“‡ä¸€å€‹ä¸­å¿ƒé»å’Œå¤§å°
                    const centerX = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const centerY = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const size = getRandom(MIN_AREA_SIZE, MAX_AREA_SIZE); 
                    
                    let overlaps = false;
                    
                    // 2. ç°¡åŒ–ç¢°æ’æª¢æ¸¬ï¼šæª¢æŸ¥ä¸­å¿ƒé»è·é›¢æ˜¯å¦è¶³å¤ é 
                    for (const existingCountry of newCountryData) {
                        const dx = centerX - existingCountry.center.x;
                        const dy = centerY - existingCountry.center.y;
                        const distanceSquared = dx * dx + dy * dy;
                        
                        // æª¢æŸ¥è·é›¢æ˜¯å¦å°æ–¼æœ€å°å…è¨±è·é›¢ï¼ˆå…©å€‹åœ‹å®¶æœ€å¤§åŠå¾‘ä¹‹å’Œçš„å¹³æ–¹ï¼‰
                        // é€™è£¡ä½¿ç”¨ç°¡åŒ–åŠå¾‘ MIN_AREA_SIZE ç¢ºä¿å®ƒå€‘ä¸æœƒå¤ªé è¿‘
                        if (distanceSquared < MIN_DISTANCE_SQUARED) {
                            overlaps = true;
                            break;
                        }
                    }
                    
                    if (!overlaps) {
                        // 3. ç”Ÿæˆå½¢ç‹€
                        const shape = generateRandomCurveShape(centerX, centerY, size * 0.5); // size * 0.5 ä½œç‚ºåŠå¾‘

                        newCountryData.push({
                            name: INITIAL_NAMES[i],
                            color: INITIAL_COLORS[i],
                            center: {x: centerX, y: centerY},
                            ...shape,
                            // size åƒæ•¸ç”¨æ–¼è¼”åŠ©ç¢°æ’æª¢æ¸¬
                            size: size 
                        });
                        safeLocationFound = true;
                    }
                }
            }
            countries = newCountryData;
            draw();
        }
        
        // ----------------------------------------------------
        // åˆå§‹åŒ–èˆ‡äº‹ä»¶ç›£è½
        // ----------------------------------------------------

        // æŒ‰éˆ•é»æ“Šäº‹ä»¶ï¼šé‡æ–°ç”Ÿæˆåœ‹å®¶
        restartButton.addEventListener('click', () => {
            generateNewCountries();
        });
        
        // ç¢ºä¿åˆå§‹è¼‰å…¥æ™‚å°±æœ‰ä¸‰å€‹åœ‹å®¶
        generateNewCountries(); 

        // èª¿æ•´ç•«å¸ƒå¤§å°ä»¥å¡«æ»¿è¦–çª—
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        // åˆå§‹å‘¼å« resizeCanvas å·²åŒ…å«åœ¨ generateNewCountries ä¹‹å¾Œï¼Œé€™è£¡ä¸å†é‡è¤‡ã€‚

        
        // ... (ä»¥ä¸‹äº’å‹•é‚è¼¯èˆ‡å‰æ¬¡ç‰ˆæœ¬å®Œå…¨ç›¸åŒ) ...
        // ----------------------------------------------------
        // äº’å‹•é‚è¼¯ - æŠ½è±¡åŒ–
        // ----------------------------------------------------
        
        function getDistance(touch1, touch2) {
            return Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) + 
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
        }
        
        function performZoom(clientX, clientY, newScale) {
            newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;

            scale = newScale;

            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;

            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);
            
            draw();
        }
        
        function handleMove(clientX, clientY) {
            if (!isDragging || isPinching) return; 

            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            panX += deltaX / scale;
            panY += deltaY / scale;
            lastX = clientX;
            lastY = clientY;
            draw();
        }

        function handleStart(clientX, clientY) {
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            canvas.classList.add('grabbing');
        }

        function handleEnd() {
            isDragging = false;
            isPinching = false;
            lastTouchDistance = null;
            canvas.classList.remove('grabbing');
        }
        
        // æ»‘é¼ äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // æ»¾è¼ªç¸®æ”¾
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            const delta = e.deltaY * -ZOOM_SPEED * 10; 
            const newScale = scale * (1 + delta);
            performZoom(e.clientX, e.clientY, newScale);
        });
        
        // è§¸æ§äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1) {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                isPinching = true;
                handleEnd(); 
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                lastTouchDistance = getDistance(t1, t2);
                touchCenter.x = (t1.clientX + t2.clientX) / 2;
                touchCenter.y = (t1.clientY + t2.clientY) / 2;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1 && !isPinching) {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                isPinching = true;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                const currentDistance = getDistance(t1, t2);
                const deltaDistance = currentDistance - lastTouchDistance;
                
                touchCenter.x = (t1.clientX + t2.clientX) / 2;
                touchCenter.y = (t1.clientY + t2.clientY) / 2;
                
                const scaleFactor = deltaDistance * 0.005; 
                const newScale = scale + (scale * scaleFactor);

                performZoom(touchCenter.x, touchCenter.y, newScale);

                lastTouchDistance = currentDistance; 
            }
        });

        window.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                handleEnd();
            } else if (e.touches.length === 1) {
                isPinching = false;
                lastTouchDistance = null;
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        window.addEventListener('touchcancel', handleEnd); 

        // ----------------------------------------------------
        // ç¹ªåœ–é‚è¼¯
        // ----------------------------------------------------

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            drawGrid();
            drawCountries(); 

            ctx.restore();
        }

        function drawCountries() {
            countries.forEach(country => {
                ctx.fillStyle = country.color;
                ctx.beginPath();
                
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                
                country.curves.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3 / scale; 
                ctx.stroke();

                
                ctx.font = `${20 / scale}px Arial`;
                ctx.fillStyle = (country.color === "#FFC107") ? "#000000" : "#ffffff"; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillText(country.name, country.center.x, country.center.y);
            });
        }


        function drawGrid() {
            let gridSize = BASE_GRID_SIZE;
            
            while (gridSize * scale < 20) {
                gridSize *= 5; 
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; 
            }

            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; 

            ctx.beginPath();

            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
    </script>
</body>
</html>
