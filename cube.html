<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 地面操作與空間旋轉 (最終版)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        /* 用於顯示軸向顏色提示 */
        #axis-legend {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10; /* 確保在最上層 */
        }
        .axis-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="axis-legend">
        軸向顏色:<br>
        <span class="axis-color" style="background-color: red;"></span>X 軸 (左右)<br>
        <span class="axis-color" style="background-color: green;"></span>Y 軸 (上下)<br>
        <span class="axis-color" style="background-color: blue;"></span>Z 軸 (前後)
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
        // --- 1. 場景初始化 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 設置光線
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // --- 2. 創建地面 (BoxGeometry 帶厚度) ---
        const groundWidth = 100;
        const groundHeight = 0.5; 
        const groundDepth = 100;
        
        const groundGeometry = new THREE.BoxGeometry(groundWidth, groundHeight, groundDepth);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.name = 'Ground';
        scene.add(ground);

        // 初始化相機位置
        camera.position.set(20, 10, 20);

        // --- 3. 設置控制器 ---
        
        // A. 空間旋轉控制器 (OrbitControls)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true; 
        
        // B. 變換控制器 (TransformControls)
        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setMode('translate'); // 移動模式
        transformControls.attach(ground);       
        scene.add(transformControls);
        
        // **修正 Z 軸顯示問題：將 Y 軸顯示設定為 true (預設值)**
        // transformControls.showY = true; // 預設就是 true，可以不用寫
        
        // 預設隱藏並禁用
        transformControls.visible = false;
        transformControls.enabled = false;

        let isGroundSelected = false; // 地面是否被選中
        
        // 監聽 TransformControls 的拖曳事件：確保在拖曳 Gizmo 時，空間旋轉被禁用
        transformControls.addEventListener('dragging-changed', function (event) {
            // 當 TransformControls 開始拖曳時，禁用 OrbitControls
            // 當 TransformControls 停止拖曳時，重新啟用 OrbitControls
            controls.enabled = !event.value;
        });
        
        // --- 4. 點擊選中與旋轉邏輯 ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function getNormalizedPointer(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        // 處理滑鼠/手指按下事件
        function onPointerDown(event) {
            getNormalizedPointer(event);
            raycaster.setFromCamera(pointer, camera);

            // 1. 檢查是否點擊到 Gizmo 本身
            if (transformControls.enabled && transformControls.visible) {
                // 如果 Gizmo 處於活動狀態，檢查射線是否與其軸相交
                const intersectsGizmo = raycaster.intersectObjects(transformControls.children, true);
                
                if (intersectsGizmo.length > 0) {
                    // 點擊到 Gizmo 的軸，交由 TransformControls 處理拖曳
                    // 此時 OrbitControls 會被 Gizmo 的 'dragging-changed' 事件禁用
                    return; 
                }
            }
            
            // 2. 檢查是否點擊到地面
            const intersectsGround = raycaster.intersectObjects([ground]);
            
            if (intersectsGround.length > 0 && intersectsGround[0].object.name === 'Ground') {
                // A. 點擊到地面 -> 選中地面
                
                isGroundSelected = true;
                
                // 啟用並顯示軸向控制器
                transformControls.visible = true;
                transformControls.enabled = true;
                
                // 為了讓單指操作軸向 Gizmo 更順暢，當選中時暫時禁用旋轉
                // 旋轉功能將在 pointerup 中被重新啟用 (如果沒有拖曳 Gizmo)
                controls.enabled = false; 

            } else {
                // B. 點擊到非地面區域
                
                if (isGroundSelected) {
                    // 符合要求：軸向顯示時，按下非地面區域，軸向要消失，但不旋轉空間。
                    
                    // 隱藏並禁用軸向控制器 (軸向消失)
                    transformControls.visible = false;
                    transformControls.enabled = false;
                    isGroundSelected = false; // 取消選中狀態
                    
                    // 保持 controls.enabled = false (不旋轉)，直到 pointerup
                    controls.enabled = false; 

                } else {
                    // 如果原本就沒有選中任何東西，啟用空間旋轉
                    controls.enabled = true;
                }
            }
        }
        
        // 處理滑鼠/手指釋放事件
        function onPointerUp(event) {
            // 在 pointerup 時，如果當前沒有選中任何東西，且 Gizmo 沒有在拖曳
            // 則啟用 OrbitControls，允許在非選中狀態下旋轉空間
            if (!isGroundSelected && !transformControls.dragging) {
                controls.enabled = true;
            }
        }

        // 監聽事件
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);

        // --- 5. 渲染迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); 
            transformControls.update(); 
            renderer.render(scene, camera);
        }

        animate();

        // --- 6. 響應式調整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
