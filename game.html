<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三欄式 3D 空間佈局 (修正執行按鈕錯誤)</title>

    <script>
        console.log("--- DEBUG START: 腳本載入中 (Line 10) ---");
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <style>
        /* 頁面整體佈局設定 */
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        .sidebar {
            width: 20%;
            background-color: #333;
            color: white;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            text-align: center;
        }
        .main-3d-container {
            width: 60%;
            background-color: #111;
            position: relative;
            cursor: default;
        }

        /* 左上角按鈕容器的樣式 */
        #top-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100; 
            display: flex; 
            flex-direction: column; 
            gap: 5px;
        }
        #editor-buttons {
            display: flex;
            gap: 10px; 
        }
        /* 按鈕的基本樣式 */
        #editor-buttons button {
            padding: 5px 10px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        #editor-buttons button:hover {
            background-color: #777;
        }
        
        /* 執行按鈕特別樣式 */
        #run-btn {
            background-color: #28a745;
        }
        #run-btn:hover {
            background-color: #1e7e34;
        }

        /* 程式碼輸出結果的樣式 */
        #code-output {
            padding: 5px 10px;
            background-color: rgba(68, 68, 68, 0.9);
            color: #d4edda; 
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
            opacity: 0; 
            transition: opacity 0.3s;
            max-width: 300px;
            white-space: pre-wrap; 
        }

        /* ------------------------------------------------ */
        /* 模態視窗樣式 (共用) */
        /* ------------------------------------------------ */
        .editor-modal { 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none; 
            justify-content: center;
            align-items: center;
        }
        .editor-content { 
            background-color: #222;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            width: 80%;
            height: 80%;
            display: flex;
            flex-direction: column;
            color: white;
            font-size: 1.2em;
        }
        /* 程式碼編輯器標題容器 (新增 flex 佈局) */
        #code-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #code-editor-header h4 {
            margin: 0;
        }
        
        /* 空間更新按鈕樣式 */
        #update-space-btn {
            padding: 5px 10px;
            background-color: #ff9800; /* 橙色 */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        #update-space-btn:hover {
             background-color: #e68900;
        }

        .editor-content button {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            align-self: flex-end;
        }
        .editor-content button:hover {
            background-color: #c82333;
        }
        #code-editor-textarea {
            flex-grow: 1;
            width: 100%;
            resize: none;
            background-color: #1a1a1a;
            color: #dddddd;
            border: 1px solid #555;
            padding: 10px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
        }
        
        /* 視覺化編輯器專用樣式 (保留不變) */
        #visual-editor-content {
            background-color: #222;
        }
        #visual-canvas-space {
            flex-grow: 1;
            width: 100%;
            margin-top: 10px;
            cursor: grab;
            background-color: #ffffff; 
            overflow: hidden;
            --grid-spacing: 20px;
            --grid-color: #aaaaaa; 
            --line-thickness: 1px;
            background-image:
                repeating-linear-gradient(to right, transparent 0, transparent calc(var(--grid-spacing) - var(--line-thickness)), var(--grid-color) calc(var(--grid-spacing) - var(--line-thickness)), var(--grid-color) var(--grid-spacing)),
                repeating-linear-gradient(to bottom, transparent 0, transparent calc(var(--grid-spacing) - var(--line-thickness)), var(--grid-color) calc(var(--grid-spacing) - var(--line-thickness)), var(--grid-color) var(--grid-spacing));
            background-size: var(--grid-spacing) var(--grid-spacing);
            background-position: 0 0;
        }
        #visual-canvas-space:active {
            cursor: grabbing;
        }

    </style>
</head>
<body>
    <div class="sidebar" id="left-sidebar">
        <h3>左側區域 (20%)</h3>
        <p>功能提示：</p>
        <p>請按住 **Shift** 鍵，然後單擊 **滑鼠左鍵** 點擊地板即可選中！</p>
    </div>
    <div class="main-3d-container" id="main-3d-container">
        <div id="top-controls">
            <div id="editor-buttons">
                <button id="code-editor-btn">程式碼編輯器</button>
                <button id="visual-editor-btn">視覺化編輯器</button>
                <button id="run-btn">執行</button>
            </div>
            <div id="code-output"></div>
        </div>

        <div id="code-editor-modal" class="editor-modal">
            <div id="code-editor-content" class="editor-content">
                <div id="code-editor-header">
                    <h4>簡易程式碼編輯器</h4>
                    <button id="update-space-btn">空間更新</button>
                </div>
                
                <textarea id="code-editor-textarea" placeholder="// 在這裡輸入程式碼，例如：print(\"hello, world\")"></textarea>
                <button id="close-code-editor-btn">關閉</button>
            </div>
        </div>
        
        <div id="visual-editor-modal" class="editor-modal">
            <div id="visual-editor-content" class="editor-content">
                <h4>視覺化編輯器 (拖曳空間)</h4>
                
                <div id="visual-canvas-space">
                    </div>
                
                <button id="close-visual-editor-btn">關閉</button>
            </div>
        </div>

        </div>
    <div class="sidebar" id="right-sidebar">
        <h3>右側區域 (20%)</h3>
        <p>滑鼠 **左鍵** 拖曳：**旋轉** 視角</p>
        <p>滑鼠 **滾輪**：縮放視角</p>
        <p>請開啟 Console 追蹤 Debug 訊息</p>
    </div>

    <script>
        // 用於記錄地板的當前尺寸 (Three.js 的 width, height, depth)
        let currentFloorDimensions = {
            width: 10,  // 對應 cube x
            height: 1,  // 對應 cube z (高度/厚度)
            depth: 10   // 對應 cube y
        };

        // 將 floor 的 Three.js 實例設為全域或在 scope 內可訪問
        let floor = null; 
        
        // 用於動畫控制的變數
        let animationTargetZ = null;    // 目標 Z 軸值
        let animationSpeedZ = 0;        // Z 軸變化速度 (單位/秒)
        let lastTime = 0;               // 上次動畫時間
        let pendingOutput = '';         // 暫存等待動畫結束後顯示的輸出
        
        // ----------------------------------------------------
        // 輔助函數：解析並更新 Three.js 幾何體 (保留不變)
        // ----------------------------------------------------
        /**
         * 解析程式碼編輯器中的 cube 數據，並更新 Three.js 場景中的 floor 物體。
         * @returns {boolean} 如果更新成功則返回 true，否則返回 false。
         */
        function updateFloorDimensionsAndGeometry(codeEditorTextarea, floor, currentFloorDimensions, renderer, camera) {
            const code = codeEditorTextarea.value;
            // 匹配 cube { x:N y:N z:N }，N可以是任意數字（包括浮點數）
            const regex = /cube\s*\{\s*x\s*:\s*(\d+(\.\d+)?)\s*y\s*:\s*(\d+(\.\d+)?)\s*z\s*:\s*(\d+(\.\d+)?)\s*\}/i;
            const match = code.match(regex);
            
            if (match) {
                // 使用索引 1, 3, 5 擷取主要數字部分 (這是為了處理帶小數點的情況)
                const newX = parseFloat(match[1]); 
                const newY = parseFloat(match[3]); 
                const newZ = parseFloat(match[5]); 

                if (isNaN(newX) || isNaN(newY) || isNaN(newZ) || newX <= 0 || newY <= 0 || newZ <= 0) {
                    console.error("空間更新失敗：尺寸值無效或非正數。");
                    return false;
                }

                if (newX === currentFloorDimensions.width &&
                    newY === currentFloorDimensions.depth &&
                    newZ === currentFloorDimensions.height) {
                    return true;
                }

                // 1. 更新全局尺寸記錄
                currentFloorDimensions.width = newX; 
                currentFloorDimensions.depth = newY; 
                currentFloorDimensions.height = newZ; 

                // 2. 實際更新 Three.js 幾何體
                floor.geometry.dispose(); 
                // BoxGeometry(width=X, height=Z, depth=Y)
                floor.geometry = new THREE.BoxGeometry(newX, newZ, newY); 
                floor.geometry.needsUpdate = true;
                floor.position.y = newZ / 2; // 調整物體中心點以保持底部在 Y=0
                
                renderer.render(floor.parent, camera); 

                console.log(`[Space Update] 成功更新地板尺寸為：X=${newX}, Y(深度)=${newY}, Z(高度)=${newZ}`);
                return true;
            } else {
                return false;
            }
        }
        
        // 輔助函數：根據當前尺寸生成程式碼 (保留不變)
        function generateCubeCode(dims) {
            // 將 Three.js (width, height, depth) 轉換為 cube (x, y, z)
            return `cube {
x:${dims.width} 
y:${dims.depth} 
z:${dims.height} 
}`;
        }
        
        // 輔助函數：解析動畫程式碼
        function parseAndSetupAnimation(code) {
            // 匹配 { cube.z<數字: cube.z+=數字 cube.z.speed=數字 }
            const regex = /\{\s*cube\.z<(\d+(\.\d+)?)\s*:\s*cube\.z\+=[^\s]*\s*cube\.z\.speed=(\d+(\.\d+)?)\s*\}/i;
            const match = code.match(regex);

            if (match) {
                const targetZ = parseFloat(match[1]);
                const speedZ = parseFloat(match[3]); 

                if (!isNaN(targetZ) && targetZ > currentFloorDimensions.height && !isNaN(speedZ) && speedZ > 0) {
                    animationTargetZ = targetZ;
                    animationSpeedZ = speedZ;
                    lastTime = performance.now(); 
                    return true;
                }
            }
            animationTargetZ = null; 
            animationSpeedZ = 0;
            return false;
        }

        // 輔助函數：解析所有 print 語句
        function parsePrintStatements(code) {
            const outputLines = [];
            
            // 排除所有與 cube 或動畫相關的行
            const lines = code.split('\n')
                .map(line => line.trim())
                .filter(line => {
                    const trimmed = line.trim();
                    return trimmed.length > 0 && 
                           !trimmed.startsWith('cube') && 
                           trimmed !== '{' && 
                           trimmed !== '}' &&
                           !trimmed.startsWith('x:') &&
                           !trimmed.startsWith('y:') &&
                           !trimmed.startsWith('z:') &&
                           !trimmed.startsWith('cube.z'); // 排除動畫行
                });
                
            lines.forEach(line => {
                const printRegex = /^print\("([^"]*)"\)$/;
                const match = line.match(printRegex);

                if (match) {
                    outputLines.push(match[1]); 
                } 
            });

            return outputLines.join('\n');
        }


        /**
         * 執行地板尺寸更新，並處理動畫邏輯。
         * @returns {string} 執行結果訊息，用於即時輸出。
         */
        function handleSpaceAndUpdateAndAnimation(codeEditorTextarea, floor, currentFloorDimensions, renderer, camera) {
             const code = codeEditorTextarea.value.trim();
             
             // 1. 嘗試執行空間更新 (cube { x: y: z: })
             const spaceUpdateSuccess = updateFloorDimensionsAndGeometry(codeEditorTextarea, floor, currentFloorDimensions, renderer, camera);
             
             // 2. 嘗試設置動畫
             const animationSetupSuccess = parseAndSetupAnimation(code);
             
             // 3. 提取所有 print 語句，並暫存結果
             const printOutput = parsePrintStatements(code);
             pendingOutput = printOutput; 

             // 4. 判斷是否有錯誤或是否需要立即輸出
             
             const allCodeLines = code.split('\n').map(line => line.trim()).filter(line => line.length > 0);
             if (allCodeLines.length > 0) {
                 const containsOnlyValidCode = allCodeLines.every(line => {
                     return line.startsWith('cube') || line.includes('{') || line.includes('}') || line.startsWith('x:') || line.startsWith('y:') || line.startsWith('z:') || line.startsWith('print(') || line.startsWith('cube.z');
                 });
                 if (!containsOnlyValidCode) {
                      console.error("[Run] 執行失敗：發現無法識別的命令。");
                      pendingOutput = ''; // 清除 print 輸出，因為執行失敗
                      return 'Execution failed: Unrecognized command.';
                 }
             }

             if (animationSetupSuccess) {
                console.log("[Run] 動畫已設定。");
                // 如果啟動了動畫，則不立即顯示 print 輸出，只顯示動畫啟動訊息
                return '動畫啟動中...';
             } else if (printOutput !== '') {
                // 沒有動畫，但有 print 輸出，則立即顯示 print 輸出，並清除暫存
                pendingOutput = '';
                return printOutput;
             }
             
             // 只有空間更新或完全為空
             return ''; 
        }


        window.onload = function() {
            console.log("--- 程式主體開始執行 (window.onload) ---");

            const container = document.getElementById('main-3d-container');
            
            // ----------------------------------------------------
            // DOM 元素獲取
            // ----------------------------------------------------
            const codeEditorBtn = document.getElementById('code-editor-btn');
            const visualEditorBtn = document.getElementById('visual-editor-btn');
            const runBtn = document.getElementById('run-btn'); 
            const updateSpaceBtn = document.getElementById('update-space-btn');

            const codeEditorModal = document.getElementById('code-editor-modal');
            const visualEditorModal = document.getElementById('visual-editor-modal');
            
            const closeCodeEditorBtn = document.getElementById('close-code-editor-btn');
            const closeVisualEditorBtn = document.getElementById('close-visual-editor-btn');

            const codeEditorTextarea = document.getElementById('code-editor-textarea'); 
            const codeOutput = document.getElementById('code-output'); 
            
            const visualCanvasSpace = document.getElementById('visual-canvas-space');
            

            if (!container) {
                console.error("致命錯誤: 找不到 ID 為 'main-3d-container' 的元素。無法初始化 Three.js。");
                return;
            }
            console.log("DOM 容器已找到。");
            
            
            // ----------------------------------------------------
            // B. Three.js 初始化 
            // ----------------------------------------------------
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 6, 10);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '1';
            container.appendChild(renderer.domElement);
            const canvasElement = renderer.domElement; 
            const controls = new THREE.OrbitControls(camera, canvasElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 20;
            const transformControls = new THREE.TransformControls(camera, canvasElement);
            scene.add(transformControls);
            transformControls.visible = false;
            transformControls.enabled = false;
            transformControls.setSize(1); 
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const clickableObjects = []; 

            // 建立地板
            const floorGeometry = new THREE.BoxGeometry(
                currentFloorDimensions.width,  // 10
                currentFloorDimensions.height, // 1
                currentFloorDimensions.depth   // 10
            );
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x444466 });
            floor = new THREE.Mesh(floorGeometry, floorMaterial); 
            floor.position.y = currentFloorDimensions.height / 2; // 將地板底部貼齊 Y=0
            scene.add(floor);
            clickableObjects.push(floor);
            
            scene.add(new THREE.AmbientLight(0xaaaaaa, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            let mouseDownPosition = { x: 0, y: 0 };
            let isDraggingTransformControls = false; 
            const clickTolerance = 5; 
            // ----------------------------------------------------
            
            
            // ----------------------------------------------------
            // A. 編輯器視窗及執行邏輯
            // ----------------------------------------------------
            
            // 輔助函數：顯示/隱藏模態視窗
            function toggleModal(modal, show) {
                modal.style.display = show ? 'flex' : 'none';
                if (controls) controls.enabled = !show;
            }

            // 顯示/隱藏輸出框的函數
            function displayOutput(output) {
                codeOutput.textContent = output;
                codeOutput.style.opacity = output === '' ? '0' : '1';

                if (output !== '') {
                    // 如果有輸出，則在 2 秒後隱藏
                    setTimeout(() => {
                        codeOutput.style.opacity = '0';
                    }, 2000); 
                }
            }


            // 程式碼編輯器 - 顯示
            codeEditorBtn.addEventListener('click', () => {
                // 檢查程式碼編輯器是否為空
                if (codeEditorTextarea.value.trim() === '') {
                    // 如果是空的，則自動載入當前物體尺寸
                    codeEditorTextarea.value = generateCubeCode(currentFloorDimensions);
                    console.log("[Editor] 程式碼編輯器開啟，因內容為空，已載入物體數據。");
                } else {
                    // 如果不為空，則保留現有內容
                    console.log("[Editor] 程式碼編輯器開啟，保留現有內容。");
                }
                
                toggleModal(codeEditorModal, true);
            });
            
            // 程式碼編輯器 - 隱藏
            closeCodeEditorBtn.addEventListener('click', () => toggleModal(codeEditorModal, false));
            
            // 視覺化編輯器事件
            visualEditorBtn.addEventListener('click', () => toggleModal(visualEditorModal, true));
            closeVisualEditorBtn.addEventListener('click', () => toggleModal(visualEditorModal, false));
            
            // 空間更新按鈕功能
            updateSpaceBtn.addEventListener('click', () => {
                const currentCode = codeEditorTextarea.value.trim();
                
                // --- 1. 檢查輸入框是否為空 ---
                if (currentCode === '') {
                    // 輸入框為空，則將當前尺寸寫入輸入框
                    codeEditorTextarea.value = generateCubeCode(currentFloorDimensions);
                    console.log("[Space Update] 輸入框為空，已將當前物體尺寸寫入程式碼。");
                    return; // 完成操作，直接返回
                }

                // --- 2. 輸入框不為空，執行更新邏輯 ---
                const success = updateFloorDimensionsAndGeometry(codeEditorTextarea, floor, currentFloorDimensions, renderer, camera);
                
                if (success) {
                    alert(`空間更新成功！地板尺寸已更新為：X=${currentFloorDimensions.width}, Y(深度)=${currentFloorDimensions.depth}, Z(高度)=${currentFloorDimensions.height}`);
                } else {
                    // 如果更新失敗 (e.g. 程式碼格式不正確)，則提示錯誤，但不清除用戶輸入
                    alert("空間更新失敗：程式碼格式不正確或尺寸值無效。");
                }
            });


            // 執行按鈕功能 (核心修改區)
            runBtn.addEventListener('click', () => {
                 const output = handleSpaceAndUpdateAndAnimation(codeEditorTextarea, floor, currentFloorDimensions, renderer, camera);

                 // 只在動畫未啟動或執行失敗時立即顯示輸出
                 if (output === 'Execution failed: Unrecognized command.' || output === '') {
                     displayOutput(output);
                 } else if (output === '動畫啟動中...') {
                     displayOutput(output);
                 } else {
                     // 這是沒有動畫時立即執行的 print 輸出
                     displayOutput(output);
                 }
            });


            // 阻止模態視窗內的事件傳播
            codeEditorModal.addEventListener('mousedown', (e) => e.stopPropagation());
            visualEditorModal.addEventListener('mousedown', (e) => e.stopPropagation());


            // ----------------------------------------------------
            // C. 視覺化編輯器拖曳邏輯 (保留不變)
            // ----------------------------------------------------
            let isDraggingVisual = false;
            let lastX, lastY;
            let bgPositionX = 0;
            let bgPositionY = 0;

            visualCanvasSpace.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; 
                isDraggingVisual = true;
                lastX = e.clientX;
                lastY = e.clientY;
                visualCanvasSpace.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingVisual) return;
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                bgPositionX += dx;
                bgPositionY += dy;
                visualCanvasSpace.style.backgroundPosition = `${bgPositionX}px ${bgPositionY}px`;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                if (isDraggingVisual) {
                    isDraggingVisual = false;
                    visualCanvasSpace.style.cursor = 'grab';
                }
            });


            // ----------------------------------------------------
            // D. Three.js 核心事件 (加入動畫邏輯)
            // ----------------------------------------------------
            transformControls.addEventListener('dragging-changed', (event) => {
                controls.enabled = !event.value;
                isDraggingTransformControls = event.value; 
            });

            canvasElement.addEventListener('mousedown', (event) => {
                if (event.button !== 0) return; 
                if (event.shiftKey) controls.enabled = false;
                mouseDownPosition = { x: event.clientX, y: event.clientY };
            }, false);

            canvasElement.addEventListener('mouseup', (event) => {
                if (event.button !== 0) return; 
                controls.enabled = true;
                if (isDraggingTransformControls) { isDraggingTransformControls = false; return; }

                const dx = Math.abs(event.clientX - mouseDownPosition.x);
                const dy = Math.abs(event.clientY - mouseDownPosition.y);
                const isClick = (dx <= clickTolerance && dy <= clickTolerance);

                if (!isClick || !event.shiftKey) return;
                
                const rect = canvasElement.getBoundingClientRect(); 
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(clickableObjects);

                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (transformControls.object !== obj) {
                             transformControls.attach(obj);
                             transformControls.setMode("translate");
                             transformControls.visible = true; 
                             transformControls.enabled = true;
                    } 
                } else {
                    transformControls.detach();
                    transformControls.visible = false; 
                    transformControls.enabled = false;
                }
                renderer.render(scene, camera); 
            }, false);


            // 動畫迴圈 (核心修改區：加入 Z 軸動畫邏輯)
            function animate(currentTime) {
                requestAnimationFrame(animate);

                // --- 處理 Z 軸動畫 ---
                if (animationTargetZ !== null && animationSpeedZ > 0 && floor) {
                    if (lastTime) {
                        const deltaTime = (currentTime - lastTime) / 1000; // 轉換為秒
                        let deltaZ = animationSpeedZ * deltaTime; // Z 軸的變化量
                        
                        let animationFinished = false;

                        if (currentFloorDimensions.height + deltaZ >= animationTargetZ) {
                            deltaZ = animationTargetZ - currentFloorDimensions.height; // 限制不超過目標值
                            animationFinished = true;
                        }
                        
                        if (deltaZ > 0) {
                            // 1. 更新全局尺寸記錄
                            currentFloorDimensions.height += deltaZ;
                            
                            // 2. 實際更新 Three.js 幾何體
                            floor.geometry.dispose();
                            // BoxGeometry(width=X, height=Z, depth=Y)
                            floor.geometry = new THREE.BoxGeometry(
                                currentFloorDimensions.width, 
                                currentFloorDimensions.height, 
                                currentFloorDimensions.depth
                            ); 
                            floor.position.y = currentFloorDimensions.height / 2; // 調整物體中心點以保持底部在 Y=0
                        }
                        
                        if (animationFinished) {
                            animationTargetZ = null; // 達到目標，停止動畫
                            animationSpeedZ = 0;
                            console.log("[Animation] Z 軸動畫完成。");
                            
                            // *** 修正點：動畫完成後，檢查並顯示暫存的 print 輸出 ***
                            if (pendingOutput !== '') {
                                console.log("[Animation] 顯示暫存輸出。");
                                displayOutput(pendingOutput);
                                pendingOutput = '';
                            }
                        }
                    }
                    lastTime = currentTime;
                }
                // --- 結束 Z 軸動畫處理 ---

                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // 響應式
            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                renderer.setSize(w, h);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            });

            // 鍵盤快速切換模式
            document.addEventListener('keydown', (e) => {
                if (!transformControls.object) return;
                switch (e.key.toLowerCase()) {
                    case 't': transformControls.setMode('translate'); break;
                    case 'r': transformControls.setMode('rotate'); break;
                    case 's': transformControls.setMode('scale'); break;
                }
            });
            
            console.log("--- 程式主體執行完畢 ---");
        };
    </script>
</body>
</html>
