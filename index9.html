<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>支援雙指縮放的無邊際平面</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; /* 禁用瀏覽器預設的觸控行為 */
        }
        #infiniteCanvas {
            display: block;
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>

    <script>
        // ----------------------------------------------------
        // 主要變數
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');

        // 畫布的狀態
        let panX = 0; 
        let panY = 0; 
        let scale = 1.0; 
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; 

        // 互動狀態變數
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // 觸控專用變數
        let isPinching = false;
        let lastTouchDistance = null; // 上次兩指之間的距離
        let touchCenter = { x: 0, y: 0 }; // 兩指的中心點

        // 網格設定
        const BASE_GRID_SIZE = 50; 
        
        // 國家標記數據 (使用三次貝茲曲線定義平滑形狀)
        const countries = [
            { 
                name: "國家 A (藍)", 
                color: "#007BFF", 
                center: {x: -100, y: -100}, 
                startPoint: {x: -250, y: -100}, 
                curves: [
                    [{x: -200, y: -250}, {x: -50, y: -250}, {x: 0, y: -100}],
                    [{x: 50, y: 50}, {x: -100, y: 150}, {x: -200, y: 50}],
                    [{x: -300, y: 0}, {x: -300, y: -50}, {x: -250, y: -100}] 
                ]
            },
            { 
                name: "國家 B (紅)", 
                color: "#DC3545", 
                center: {x: 100, y: 100},
                startPoint: {x: 50, y: 0},
                curves: [
                    [{x: 200, y: 0}, {x: 250, y: 50}, {x: 200, y: 150}],
                    [{x: 150, y: 250}, {x: 0, y: 200}, {x: 0, y: 100}],
                    [{x: -50, y: 50}, {x: 0, y: 0}, {x: 50, y: 0}] 
                ]
            },      
            { 
                name: "國家 C (黃)", 
                color: "#FFC107", 
                center: {x: -200, y: 300},
                startPoint: {x: -300, y: 200},
                curves: [
                    [{x: -150, y: 350}, {x: -50, y: 350}, {x: 0, y: 300}],
                    [{x: 50, y: 200}, {x: -50, y: 100}, {x: -200, y: 150}],
                    [{x: -350, y: 200}, {x: -350, y: 250}, {x: -300, y: 200}] 
                ]
            }     
        ];

        // ----------------------------------------------------
        // 初始化與公用函數
        // ----------------------------------------------------

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); 

        // ----------------------------------------------------
        // 互動邏輯 - 抽象化
        // ----------------------------------------------------
        
        /**
         * 執行縮放操作 (通用邏輯)
         * @param {number} clientX - 縮放中心點的 X 螢幕座標
         * @param {number} clientY - 縮放中心點的 Y 螢幕座標
         * @param {number} newScale - 欲達到的新的縮放比例
         */
        function performZoom(clientX, clientY, newScale) {
            // 限制縮放範圍
            newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            // 1. 取得縮放前，中心點對應的世界座標
            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;

            // 2. 更新縮放比例
            scale = newScale;

            // 3. 取得縮放後，中心點對應的世界座標
            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;

            // 4. 計算平移量補償 (實現以中心點為中心縮放)
            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);
            
            draw();
        }
        
        // --- 拖曳/平移函數 ---
        function handleMove(clientX, clientY) {
            if (!isDragging || isPinching) return; // 捏合時禁用拖曳

            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            panX += deltaX / scale;
            panY += deltaY / scale;
            lastX = clientX;
            lastY = clientY;
            draw();
        }

        function handleStart(clientX, clientY) {
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            canvas.classList.add('grabbing');
        }

        function handleEnd() {
            isDragging = false;
            isPinching = false;
            lastTouchDistance = null;
            canvas.classList.remove('grabbing');
        }

        // ----------------------------------------------------
        // 1. 滑鼠事件 (桌面)
        // ----------------------------------------------------
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // 滾輪縮放 (桌面)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            // 滾輪縮放因子是線性的
            const delta = e.deltaY * -ZOOM_SPEED * 10; // 乘以 10 讓縮放更靈敏
            const newScale = scale * (1 + delta);
            performZoom(e.clientX, e.clientY, newScale);
        });
        
        // ----------------------------------------------------
        // 2. 觸控事件 (行動裝置)
        // ----------------------------------------------------

        function getDistance(touch1, touch2) {
            return Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) + 
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1) {
                // 單指：開始拖曳
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                // 雙指：開始縮放
                isPinching = true;
                handleEnd(); // 停止可能的單指拖曳狀態
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                lastTouchDistance = getDistance(t1, t2);
                touchCenter.x = (t1.clientX + t2.clientX) / 2;
                touchCenter.y = (t1.clientY + t2.clientY) / 2;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1 && !isPinching) {
                // 單指移動 (平移)
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                // 雙指移動 (縮放)
                isPinching = true;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                const currentDistance = getDistance(t1, t2);
                const deltaDistance = currentDistance - lastTouchDistance;
                
                // 計算縮放中心 (兩指中心點)
                touchCenter.x = (t1.clientX + t2.clientX) / 2;
                touchCenter.y = (t1.clientY + t2.clientY) / 2;
                
                // 根據距離變化量計算新的縮放比例
                const scaleFactor = deltaDistance * 0.005; // 縮放敏感度調整
                const newScale = scale + (scale * scaleFactor);

                performZoom(touchCenter.x, touchCenter.y, newScale);

                lastTouchDistance = currentDistance; // 更新距離
            }
        });

        window.addEventListener('touchend', (e) => {
            // 如果所有手指都抬起，則結束所有操作
            if (e.touches.length === 0) {
                handleEnd();
            } else if (e.touches.length === 1) {
                // 如果只剩一根手指，重置捏合狀態，並為潛在的單指拖曳準備
                isPinching = false;
                lastTouchDistance = null;
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        window.addEventListener('touchcancel', handleEnd); 

        // ----------------------------------------------------
        // 繪圖邏輯 (與前次版本相同)
        // ----------------------------------------------------

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // 應用變換矩陣
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            drawGrid();
            drawCountries(); 

            ctx.restore();
        }

        function drawCountries() {
            countries.forEach(country => {
                ctx.fillStyle = country.color;
                ctx.beginPath();
                
                // 1. 移動到曲線起始點
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                
                // 2. 依序繪製三次貝茲曲線段
                country.curves.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                
                // 3. 閉合路徑並填充
                ctx.closePath();
                ctx.fill();
                
                // 繪製邊框
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3 / scale; 
                ctx.stroke();

                
                // 繪製國家名稱
                ctx.font = `${20 / scale}px Arial`;
                ctx.fillStyle = (country.color === "#FFC107") ? "#000000" : "#ffffff"; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillText(country.name, country.center.x, country.center.y);
            });
        }


        function drawGrid() {
            let gridSize = BASE_GRID_SIZE;
            
            while (gridSize * scale < 20) {
                gridSize *= 5; 
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; 
            }

            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; 

            ctx.beginPath();

            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            // 繪製主要網格
            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
    </script>
</body>
</html>
