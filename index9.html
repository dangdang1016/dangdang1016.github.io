<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>網頁版無邊際平面</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 隱藏滾動條 */
            background-color: #f0f0f0;
        }
        #infiniteCanvas {
            display: block;
            cursor: grab; /* 拖曳時的游標 */
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>

    <script>
        // ----------------------------------------------------
        // 主要變數
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');

        // 畫布的狀態：平移偏移量和縮放比例
        let panX = 0; // X 軸平移偏移量 (在世界座標系中)
        let panY = 0; // Y 軸平移偏移量 (在世界座標系中)
        let scale = 1.0; // 縮放比例
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; // 滾輪縮放速度

        // 滑鼠/拖曳相關變數
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // 網格設定
        const BASE_GRID_SIZE = 50; // 基礎網格單元大小 (世界座標單位)

        // ----------------------------------------------------
        // 初始化與事件監聽
        // ----------------------------------------------------

        // 調整畫布大小以填滿視窗
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // 初始呼叫

        // 滑鼠按下 (開始拖曳)
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.classList.add('grabbing');
        });

        // 滑鼠移動 (平移)
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            // 計算滑鼠移動的像素距離
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;

            // 將像素距離轉換為世界座標距離 (需要考慮縮放)
            // panX 和 panY 儲存的是世界座標的偏移量
            panX += deltaX / scale;
            panY += deltaY / scale;

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            draw();
        });

        // 滑鼠放開 (結束拖曳)
        window.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.classList.remove('grabbing');
        });

        // 滑鼠滾輪 (縮放)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); // 防止頁面滾動

            // 計算縮放因子
            const delta = e.deltaY * -ZOOM_SPEED;
            const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * (1 + delta)));

            // 縮放中心點 (以滑鼠位置為中心)
            // 將螢幕座標 (e.clientX, e.clientY) 轉換為世界座標 (worldX, worldY)
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // 1. 取得縮放前，滑鼠點對應的世界座標
            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;

            // 2. 更新縮放比例
            scale = newScale;

            // 3. 取得縮放後，滑鼠點對應的世界座標 (理想情況下應該一樣)
            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;

            // 4. 計算平移量補償，確保滑鼠點在縮放前後的世界座標不變
            // 新的 pan = 舊的 pan + (世界座標變動量)
            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);

            draw();
        });

        // ----------------------------------------------------
        // 繪圖邏輯
        // ----------------------------------------------------

        function draw() {
            // 清空畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 儲存狀態，以便在繪製網格後恢復
            ctx.save();

            // 將原點平移到畫布中心 (這樣縮放時才會以中心為原點)
            ctx.translate(canvas.width / 2, canvas.height / 2);

            // 執行縮放操作
            ctx.scale(scale, scale);

            // 執行平移操作 (panX, panY 是世界座標系上的偏移量)
            ctx.translate(panX, panY);

            // 繪製網格
            drawGrid();

            // 繪製座標軸 (可選)
            drawAxes();
            
            // 繪製一個固定在世界座標 (100, 100) 的點 (測試用)
            drawWorldPoint(100, 100);

            // 恢復畫布狀態
            ctx.restore();
        }

        function drawGrid() {
            // 根據縮放比例調整網格間距
            let gridSize = BASE_GRID_SIZE;
            
            // 讓網格大小隨著縮放級別變化，保持視覺上的合理性
            // 確保網格在螢幕上可見且不至於過密或過疏
            while (gridSize * scale < 20) {
                gridSize *= 5; // 縮小時，增加間距
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; // 放大時，減小間距
            }

            // 計算畫布可視範圍在世界座標中的邊界
            // 注意：我們已經在 draw 函數中將原點平移到中心並進行了縮放和平移操作，
            // 這裡的座標轉換比較直觀，只需要考慮已經設置的變換。
            
            // 可視範圍的左上角世界座標
            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;

            // 可視範圍的右下角世界座標
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; // 保持線寬在螢幕上一致

            ctx.beginPath();

            // 繪製垂直線
            // 找到第一個可見網格線的 X 座標
            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            // 繪製水平線
            // 找到第一個可見網格線的 Y 座標
            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            // 繪製主要網格 (更深的顏色，例如每 5 個單位)
            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                // 繪製垂直線
                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                // 繪製水平線
                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
        
        function drawAxes() {
            const axisLength = 5000; // 繪製一段很長的線來模擬無限

            ctx.lineWidth = 2 / scale; // 保持線寬一致
            ctx.font = `${10 / scale}px Arial`; // 保持字體大小一致
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // X 軸 (紅色)
            ctx.strokeStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(-axisLength, 0);
            ctx.lineTo(axisLength, 0);
            ctx.stroke();
            // 繪製原點標記
            ctx.fillStyle = '#ff0000';
            ctx.fillText('X', axisLength / 2, 10 / scale);


            // Y 軸 (藍色)
            ctx.strokeStyle = '#0000ff';
            ctx.beginPath();
            ctx.moveTo(0, -axisLength);
            ctx.lineTo(0, axisLength);
            ctx.stroke();
            // 繪製原點標記
            ctx.fillStyle = '#0000ff';
            ctx.fillText('Y', 10 / scale, -axisLength / 2);
            
            // 原點 (黑色點)
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(0, 0, 5 / scale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawWorldPoint(x, y) {
            ctx.fillStyle = '#008000';
            ctx.beginPath();
            ctx.arc(x, y, 10 / scale, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000000';
            ctx.font = `${20 / scale}px Arial`;
            ctx.fillText(`(${x}, ${y})`, x, y - 20 / scale);
        }

    </script>
</body>
</html>
