<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç„¡é‚Šéš›å¹³é¢èˆ‡ä¸Šä¸‹æ–‡é¸å–®</title>
    <style>
        /* ã€é—œéµä¿®æ­£ã€‘ç¢ºä¿ HTML å’Œ BODY ä½”æ»¿æ•´å€‹è¦–çª—ç©ºé–“ */
        html, body {
            height: 100%; 
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; 
        }
        
        /* ã€é—œéµä¿®æ­£ã€‘ç¢ºä¿ Canvas ä½”æ»¿æ•´å€‹ body ç©ºé–“ */
        #infiniteCanvas {
            display: block;
            height: 100%; /* ç¢ºä¿ CSS é¡¯ç¤ºå¤§å°ç‚º 100% */
            width: 100%;  /* ç¢ºä¿ CSS é¡¯ç¤ºå¤§å°ç‚º 100% */
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
        
        /* é‡æ–°é–‹å§‹æŒ‰éˆ•æ¨£å¼ */
        #restartButton {
            position: fixed; 
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* ä¸Šä¸‹æ–‡é¸å–®æ¨£å¼ */
        #contextMenu {
            position: fixed;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            padding: 0;
            margin: 0;
            list-style: none;
            display: none; 
            z-index: 20; 
        }
        #contextMenu li {
            padding: 10px 20px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #contextMenu li:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>
    <button id="restartButton">ğŸ”„ é‡æ–°é–‹å§‹</button>

    <ul id="contextMenu">
        <li id="countryStatusOption">åœ‹å®¶æƒ…æ³</li>
    </ul>

    <script>
        // ----------------------------------------------------
        // ä¸»è¦è®Šæ•¸
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');
        const restartButton = document.getElementById('restartButton');
        const contextMenu = document.getElementById('contextMenu');

        // ç•«å¸ƒçš„ç‹€æ…‹
        let panX = 0; 
        let panY = 0; 
        let scale = 1.0; 
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; 

        // äº’å‹•ç‹€æ…‹è®Šæ•¸
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // è§¸æ§å°ˆç”¨è®Šæ•¸
        let isPinching = false;
        let lastTouchDistance = null; 
        
        // é•·æŒ‰/é¸å–®è®Šæ•¸
        let longPressTimer = null;
        const LONG_PRESS_DURATION = 500; // 500ms
        let currentLongPressTarget = null; 
        
        // ç¶²æ ¼è¨­å®šèˆ‡åœ‹å®¶æ•¸æ“š
        const BASE_GRID_SIZE = 50; 
        const INITIAL_COLORS = ["#007BFF", "#DC3545", "#FFC107"];
        const INITIAL_NAMES = ["åœ‹å®¶ A", "åœ‹å®¶ B", "åœ‹å®¶ C"];
        let countries = []; 
        const MIN_AREA_SIZE = 150; 
        const MAX_AREA_SIZE = 300; 
        const WORLD_BOUNDARY = 800; 
        const MIN_DISTANCE_SQUARED = Math.pow(MIN_AREA_SIZE * 1.5, 2);
        
        // ----------------------------------------------------
        // å¹¾ä½•ã€ç”Ÿæˆèˆ‡ç¢°æ’æª¢æ¸¬å‡½æ•¸
        // ----------------------------------------------------

        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        function generateRandomCurveShape(centerX, centerY, size) {
            const NUM_POINTS = 6; 
            const shapeData = { startPoint: {x: 0, y: 0}, curves: [] };
            let currentX = centerX + size * Math.cos(0);
            let currentY = centerY + size * Math.sin(0);
            shapeData.startPoint = {x: currentX, y: currentY};
            
            for (let i = 0; i < NUM_POINTS; i++) {
                const angle3 = (i + 1) * (Math.PI * 2 / NUM_POINTS);
                const endX = centerX + size * getRandom(0.8, 1.2) * Math.cos(angle3);
                const endY = centerY + size * getRandom(0.8, 1.2) * Math.sin(angle3);
                const cp1X = currentX + (endX - currentX) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                const cp1Y = currentY + (endY - currentY) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                const cp2X = currentX + (endX - currentX) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);
                const cp2Y = currentY + (endY - currentY) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);
                shapeData.curves.push([{x: cp1X, y: cp1Y}, {x: cp2X, y: cp2Y}, {x: endX, y: endY}]);
                currentX = endX;
                currentY = endY;
            }
            shapeData.curves[NUM_POINTS - 1][2] = shapeData.startPoint; 
            return shapeData;
        }

        function generateNewCountries() {
            countries = [];
            const newCountryData = [];
            for (let i = 0; i < INITIAL_COLORS.length; i++) {
                let safeLocationFound = false;
                let attempts = 0;
                while (!safeLocationFound && attempts < 100) {
                    attempts++;
                    const centerX = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const centerY = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const size = getRandom(MIN_AREA_SIZE, MAX_AREA_SIZE); 
                    let overlaps = false;
                    for (const existingCountry of newCountryData) {
                        const dx = centerX - existingCountry.center.x;
                        const dy = centerY - existingCountry.center.y;
                        const distanceSquared = dx * dx + dy * dy;
                        if (distanceSquared < MIN_DISTANCE_SQUARED) { overlaps = true; break; }
                    }
                    if (!overlaps) {
                        const shape = generateRandomCurveShape(centerX, centerY, size * 0.5); 
                        newCountryData.push({
                            name: INITIAL_NAMES[i],
                            color: INITIAL_COLORS[i],
                            center: {x: centerX, y: centerY},
                            ...shape,
                            size: size 
                        });
                        safeLocationFound = true;
                    }
                }
            }
            countries = newCountryData;
            draw();
        }

        function hitTestCountry(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;
            
            // é€†å‘è®Šæ›è¨ˆç®—ä¸–ç•Œåº§æ¨™
            const worldX = (canvasX - canvas.width / 2) / scale - panX;
            const worldY = (canvasY - canvas.height / 2) / scale - panY;

            for (const country of countries) {
                // å¿…é ˆé‡æ–°å»ºç«‹è·¯å¾‘
                ctx.beginPath();
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                country.curves.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                ctx.closePath();

                if (ctx.isPointInPath(worldX, worldY)) {
                    return country; 
                }
            }
            return null; 
        }

        // ----------------------------------------------------
        // é¸å–®èˆ‡é•·æŒ‰é‚è¼¯
        // ----------------------------------------------------

        function showContextMenu(clientX, clientY, country) {
            contextMenu.style.left = `${clientX}px`;
            contextMenu.style.top = `${clientY}px`;
            contextMenu.style.display = 'block';
            currentLongPressTarget = country;
            
            document.getElementById('countryStatusOption').innerText = `åœ‹å®¶æƒ…æ³ (${country.name})`;
        }
        
        function hideContextMenu() {
            contextMenu.style.display = 'none';
            currentLongPressTarget = null;
        }

        document.getElementById('countryStatusOption').addEventListener('click', () => {
            if (currentLongPressTarget) {
                alert(`æŸ¥çœ‹ ${currentLongPressTarget.name} çš„åœ‹å®¶æƒ…æ³ï¼`);
                hideContextMenu();
            }
        });
        
        window.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target) && e.target.id !== 'restartButton') {
                hideContextMenu();
            }
        });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());


        // ----------------------------------------------------
        // äº’å‹•é‚è¼¯ (æ ¸å¿ƒ)
        // ----------------------------------------------------
        
        function getDistance(touch1, touch2) {
            return Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) + 
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
        }
        
        function performZoom(clientX, clientY, newScale) {
            newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;
            scale = newScale;
            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;
            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);
            draw();
        }
        
        function handleMove(clientX, clientY) {
            if (!isDragging || isPinching) return; 
            
            // åµæ¸¬ç§»å‹•è·é›¢ï¼Œè¶…éé–¾å€¼å³å–æ¶ˆé•·æŒ‰
            if (longPressTimer) {
                const distanceMoved = Math.sqrt(Math.pow(clientX - lastX, 2) + Math.pow(clientY - lastY, 2));
                if (distanceMoved > 5) { 
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }

            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            panX += deltaX / scale;
            panY += deltaY / scale;
            lastX = clientX;
            lastY = clientY;
            draw();
        }

        function handleStart(clientX, clientY) {
            hideContextMenu(); 
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            canvas.classList.add('grabbing');
            
            // è¨­ç½®é•·æŒ‰è¨ˆæ™‚å™¨
            const targetCountry = hitTestCountry(clientX, clientY);
            if (targetCountry) {
                longPressTimer = setTimeout(() => {
                    showContextMenu(clientX, clientY, targetCountry);
                    longPressTimer = null; 
                    isDragging = false; 
                }, LONG_PRESS_DURATION);
            }
        }

        function handleEnd() {
            clearTimeout(longPressTimer); 
            longPressTimer = null;
            isDragging = false;
            isPinching = false;
            lastTouchDistance = null;
            canvas.classList.remove('grabbing');
        }
        
        // ----------------------------------------------------
        // äº‹ä»¶ç›£è½
        // ----------------------------------------------------
        
        // æ»‘é¼ äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // æ»¾è¼ªç¸®æ”¾
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            const delta = e.deltaY * -ZOOM_SPEED * 10; 
            const newScale = scale * (1 + delta);
            performZoom(e.clientX, e.clientY, newScale);
        });
        
        // è§¸æ§äº‹ä»¶
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1) {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                clearTimeout(longPressTimer); 
                longPressTimer = null;
                isPinching = true;
                handleEnd(); 
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                lastTouchDistance = getDistance(t1, t2);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1 && !isPinching) {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                isPinching = true;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                const currentDistance = getDistance(t1, t2);
                const deltaDistance = currentDistance - lastTouchDistance;
                
                const touchCenter = { 
                    x: (t1.clientX + t2.clientX) / 2, 
                    y: (t1.clientY + t2.clientY) / 2 
                };
                
                const scaleFactor = deltaDistance * 0.005; 
                const newScale = scale + (scale * scaleFactor);

                performZoom(touchCenter.x, touchCenter.y, newScale);
                lastTouchDistance = currentDistance; 
            }
        });

        window.addEventListener('touchend', (e) => {
            handleEnd(); 
            if (e.touches.length === 1) {
                isPinching = false;
                lastTouchDistance = null;
            }
        });
        window.addEventListener('touchcancel', handleEnd); 
        
        // é‡æ–°é–‹å§‹æŒ‰éˆ•äº‹ä»¶
        restartButton.addEventListener('click', () => {
            // é»æ“Šé‡æ–°é–‹å§‹æ™‚ï¼Œå°‡è¦–åœ–é‡ç½®åˆ°ä¸–ç•Œåº§æ¨™åŸé»
            panX = 0;
            panY = 0;
            scale = 1.0;
            hideContextMenu();
            generateNewCountries();
        });

        // ----------------------------------------------------
        // ç¹ªåœ–é‚è¼¯
        // ----------------------------------------------------

        function draw() {
            // æ¯æ¬¡ç¹ªåœ–å‰æ¸…é™¤æ•´å€‹ç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // æ‡‰ç”¨è®Šæ›çŸ©é™£
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            drawGrid();
            drawCountries(); 

            ctx.restore();
        }

        function drawCountries() {
            countries.forEach(country => {
                ctx.fillStyle = country.color;
                ctx.beginPath();
                
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                
                country.curves.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3 / scale; 
                ctx.stroke();

                
                ctx.font = `${20 / scale}px Arial`;
                ctx.fillStyle = (country.color === "#FFC107") ? "#000000" : "#ffffff"; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillText(country.name, country.center.x, country.center.y);
            });
        }


        function drawGrid() {
            let gridSize = BASE_GRID_SIZE;
            
            while (gridSize * scale < 20) {
                gridSize *= 5; 
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; 
            }

            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; 

            ctx.beginPath();

            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
        
        // ----------------------------------------------------
        // å•Ÿå‹•é»
        // ----------------------------------------------------
        
        // èª¿æ•´ç•«å¸ƒå¤§å°ä»¥å¡«æ»¿è¦–çª—
        function resizeCanvas() {
            // ã€é—œéµé»ã€‘å¿…é ˆåŒæ™‚è¨­å®š Canvas å…ƒç´ çš„ "åƒç´ " å¯¬é«˜
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        
        resizeCanvas(); // åˆå§‹å‘¼å«ï¼Œè¨­å®šæ­£ç¢ºçš„ç•«å¸ƒå°ºå¯¸
        generateNewCountries(); // ç¢ºä¿åˆå§‹è¼‰å…¥æ™‚å°±æœ‰ä¸‰å€‹åœ‹å®¶
    </script>
</body>
</html>
