<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>無邊際平面與不規則曲線標記</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; /* 禁用瀏覽器預設的觸控行為 */
        }
        #infiniteCanvas {
            display: block;
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>

    <script>
        // ----------------------------------------------------
        // 主要變數
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');

        // 畫布的狀態
        let panX = 0; 
        let panY = 0; 
        let scale = 1.0; 
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; 

        // 互動狀態變數
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        // 網格設定
        const BASE_GRID_SIZE = 50; 
        
        // 國家標記數據 (使用三次貝茲曲線定義平滑形狀)
        // shape 陣列中的每個元素定義了一段曲線：[控制點1, 控制點2, 結束點]
        const countries = [
            { 
                name: "國家 A (藍)", 
                color: "#007BFF", 
                center: {x: -100, y: -100}, // 文字中心點
                // 曲線段的定義：每段從上一個結束點開始
                // 格式: [{cp1x, cp1y}, {cp2x, cp2y}, {endX, endY}]
                startPoint: {x: -250, y: -100}, // 曲線起始點
                curves: [
                    [{x: -200, y: -250}, {x: -50, y: -250}, {x: 0, y: -100}],
                    [{x: 50, y: 50}, {x: -100, y: 150}, {x: -200, y: 50}],
                    [{x: -300, y: 0}, {x: -300, y: -50}, {x: -250, y: -100}] // 閉合回起始點
                ]
            },
            { 
                name: "國家 B (紅)", 
                color: "#DC3545", 
                center: {x: 100, y: 100},
                startPoint: {x: 50, y: 0},
                curves: [
                    [{x: 200, y: 0}, {x: 250, y: 50}, {x: 200, y: 150}],
                    [{x: 150, y: 250}, {x: 0, y: 200}, {x: 0, y: 100}],
                    [{x: -50, y: 50}, {x: 0, y: 0}, {x: 50, y: 0}] 
                ]
            },      
            { 
                name: "國家 C (黃)", 
                color: "#FFC107", 
                center: {x: -200, y: 300},
                startPoint: {x: -300, y: 200},
                curves: [
                    [{x: -150, y: 350}, {x: -50, y: 350}, {x: 0, y: 300}],
                    [{x: 50, y: 200}, {x: -50, y: 100}, {x: -200, y: 150}],
                    [{x: -350, y: 200}, {x: -350, y: 250}, {x: -300, y: 200}] 
                ]
            }     
        ];

        // ----------------------------------------------------
        // 初始化與互動函數 (保持與前次版本相同)
        // ----------------------------------------------------

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); 

        function handleMove(clientX, clientY) {
            if (!isDragging) return;
            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            panX += deltaX / scale;
            panY += deltaY / scale;
            lastX = clientX;
            lastY = clientY;
            draw();
        }

        function handleStart(clientX, clientY) {
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            canvas.classList.add('grabbing');
        }

        function handleEnd() {
            isDragging = false;
            canvas.classList.remove('grabbing');
        }
        
        // 滑鼠事件
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // 觸控事件
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault(); 
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault(); 
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        window.addEventListener('touchend', handleEnd);
        window.addEventListener('touchcancel', handleEnd); 

        // 滾輪事件
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            const delta = e.deltaY * -ZOOM_SPEED;
            const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * (1 + delta)));

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;

            scale = newScale;

            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;

            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);

            draw();
        });


        // ----------------------------------------------------
        // 繪圖邏輯
        // ----------------------------------------------------

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // 應用變換矩陣
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            drawGrid();
            drawCountries(); // <-- 繪製不規則曲線國家標記

            ctx.restore();
        }

        /**
         * 繪製不規則曲線形狀的國家
         */
        function drawCountries() {
            countries.forEach(country => {
                ctx.fillStyle = country.color;
                ctx.beginPath();
                
                // 1. 移動到曲線起始點
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                
                // 2. 依序繪製三次貝茲曲線段
                country.curves.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    
                    // ctx.bezierCurveTo(控制點1x, 控制點1y, 控制點2x, 控制點2y, 結束點x, 結束點y)
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                
                // 3. 閉合路徑並填充
                ctx.closePath();
                ctx.fill();
                
                // 繪製邊框
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3 / scale; 
                ctx.stroke();

                
                // 繪製國家名稱
                ctx.font = `${20 / scale}px Arial`;
                ctx.fillStyle = (country.color === "#FFC107") ? "#000000" : "#ffffff"; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 使用預定義的中心點 (center) 來放置文字
                ctx.fillText(country.name, country.center.x, country.center.y);
            });
        }


        function drawGrid() {
            let gridSize = BASE_GRID_SIZE;
            
            while (gridSize * scale < 20) {
                gridSize *= 5; 
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; 
            }

            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; 

            ctx.beginPath();

            // 繪製垂直線
            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            // 繪製水平線
            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            // 繪製主要網格
            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
    </script>
</body>
</html>
