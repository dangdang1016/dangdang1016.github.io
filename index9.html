<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç„¡é‚Šéš›å¹³é¢èˆ‡ä¸Šä¸‹æ–‡é¸å–®</title>
    <style>
        /* ç¢ºä¿ HTML å’Œ BODY ä½”æ»¿æ•´å€‹è¦–çª—ç©ºé–“ */
        html, body {
            height: 100%; 
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; 
        }
        
        /* ç¢ºä¿ Canvas ä½”æ»¿æ•´å€‹ body ç©ºé–“ */
        #infiniteCanvas {
            display: block;
            height: 100%; 
            width: 100%;  
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
        
        /* é‡æ–°é–‹å§‹æŒ‰éˆ•æ¨£å¼ */
        #restartButton {
            position: fixed; 
            top: 20px;
            left: 20px;
            padding: 10px 15px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* ä¸Šä¸‹æ–‡é¸å–®æ¨£å¼ */
        #contextMenu {
            position: fixed;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            padding: 0;
            margin: 0;
            list-style: none;
            display: none; /* é è¨­éš±è— */
            z-index: 20; 
        }
        #contextMenu li {
            padding: 10px 20px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #contextMenu li:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>
    <button id="restartButton">ğŸ”„ é‡æ–°é–‹å§‹</button>

    <ul id="contextMenu">
        <li id="countryStatusOption">åœ‹å®¶æƒ…æ³</li>
    </ul>

    <script>
        // ----------------------------------------------------
        // ä¸»è¦è®Šæ•¸
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');
        const restartButton = document.getElementById('restartButton');
        const contextMenu = document.getElementById('contextMenu');

        // ç•«å¸ƒçš„ç‹€æ…‹
        let panX = 0; 
        let panY = 0; 
        let scale = 1.0; 
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; 

        // äº’å‹•ç‹€æ…‹è®Šæ•¸
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // è§¸æ§å°ˆç”¨è®Šæ•¸
        let isPinching = false;
        let lastTouchDistance = null; 
        
        // é•·æŒ‰/é¸å–®è®Šæ•¸
        let longPressTimer = null;
        const LONG_PRESS_DURATION = 500; // 500ms
        let currentLongPressTarget = null; // å„²å­˜é•·æŒ‰é¸ä¸­çš„åœ‹å®¶
        
        // ç¶²æ ¼è¨­å®šèˆ‡åœ‹å®¶æ•¸æ“š
        const BASE_GRID_SIZE = 50; 
        const INITIAL_COLORS = ["#007BFF", "#DC3545", "#FFC107"];
        const INITIAL_NAMES = ["åœ‹å®¶ A", "åœ‹å®¶ B", "åœ‹å®¶ C"];
        let countries = []; 
        const MIN_AREA_SIZE = 150; 
        const MAX_AREA_SIZE = 300; 
        const WORLD_BOUNDARY = 800; 
        const MIN_DISTANCE_SQUARED = Math.pow(MIN_AREA_SIZE * 1.5, 2);
        
        // ----------------------------------------------------
        // å¹¾ä½•ã€ç”Ÿæˆèˆ‡ç¢°æ’æª¢æ¸¬å‡½æ•¸
        // ----------------------------------------------------

        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        function generateRandomCurveShape(centerX, centerY, size) {
            const NUM_POINTS = 6; 
            const shapeData = { startPoint: {x: 0, y: 0}, curves: [] };
            let currentX = centerX + size * Math.cos(0);
            let currentY = centerY + size * Math.sin(0);
            shapeData.startPoint = {x: currentX, y: currentY};
            // ... (æ›²ç·šç”Ÿæˆé‚è¼¯èˆ‡å‰æ¬¡ç‰ˆæœ¬ç›¸åŒï¼Œç¢ºä¿éš¨æ©Ÿå¹³æ»‘ä¸è¦å‰‡)
            for (let i = 0; i < NUM_POINTS; i++) {
                const angle3 = (i + 1) * (Math.PI * 2 / NUM_POINTS);
                const endX = centerX + size * getRandom(0.8, 1.2) * Math.cos(angle3);
                const endY = centerY + size * getRandom(0.8, 1.2) * Math.sin(angle3);
                const cp1X = currentX + (endX - currentX) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                const cp1Y = currentY + (endY - currentY) * getRandom(0.2, 0.4) + size * getRandom(-0.5, 0.5);
                const cp2X = currentX + (endX - currentX) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);
                const cp2Y = currentY + (endY - currentY) * getRandom(0.6, 0.8) + size * getRandom(-0.5, 0.5);
                shapeData.curves.push([{x: cp1X, y: cp1Y}, {x: cp2X, y: cp2Y}, {x: endX, y: endY}]);
                currentX = endX;
                currentY = endY;
            }
            shapeData.curves[NUM_POINTS - 1][2] = shapeData.startPoint; 
            return shapeData;
        }

        function generateNewCountries() {
            countries = [];
            const newCountryData = [];
            for (let i = 0; i < INITIAL_COLORS.length; i++) {
                let safeLocationFound = false;
                let attempts = 0;
                while (!safeLocationFound && attempts < 100) {
                    attempts++;
                    const centerX = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const centerY = getRandom(-WORLD_BOUNDARY, WORLD_BOUNDARY);
                    const size = getRandom(MIN_AREA_SIZE, MAX_AREA_SIZE); 
                    let overlaps = false;
                    for (const existingCountry of newCountryData) {
                        const dx = centerX - existingCountry.center.x;
                        const dy = centerY - existingCountry.center.y;
                        const distanceSquared = dx * dx + dy * dy;
                        if (distanceSquared < MIN_DISTANCE_SQUARED) { overlaps = true; break; }
                    }
                    if (!overlaps) {
                        const shape = generateRandomCurveShape(centerX, centerY, size * 0.5); 
                        newCountryData.push({
                            name: INITIAL_NAMES[i],
                            color: INITIAL_COLORS[i],
                            center: {x: centerX, y: centerY},
                            ...shape,
                            size: size 
                        });
                        safeLocationFound = true;
                    }
                }
            }
            countries = newCountryData;
            draw();
        }

        /**
         * åŸ·è¡Œé»æ“Šæ¸¬è©¦ï¼Œç¢ºå®šå“ªå€‹åœ‹å®¶åŒ…å«è¢å¹•åº§æ¨™ (clientX, clientY)
         * @param {number} clientX - é»æ“Šçš„è¢å¹• X åº§æ¨™
         * @param {number} clientY - é»æ“Šçš„è¢å¹• Y åº§æ¨™
         * @returns {object|null} - è¢«é»æ“Šçš„åœ‹å®¶ç‰©ä»¶ï¼Œå¦‚æœæ²’æœ‰å‰‡è¿”å› null
         */
        function hitTestCountry(clientX, clientY) {
            // ç”±æ–¼ Canvas çš„è®Šæ›ï¼Œæˆ‘å€‘éœ€è¦å°‡ç¹ªè£½é‚è¼¯è¤‡è£½åˆ°é€™è£¡ï¼Œä½†ä½¿ç”¨ isPointInPath é€²è¡Œæ¸¬è©¦
            
            // é€†å‘è®Šæ›: å°‡è¢å¹•åº§æ¨™è½‰æ›ç‚ºä¸–ç•Œåº§æ¨™
            const rect = canvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;
            
            // 1. ç§»é™¤ Canvas ä¸­å¿ƒå¹³ç§» (canvas.width / 2)
            const translatedX = canvasX - canvas.width / 2;
            const translatedY = canvasY - canvas.height / 2;
            
            // 2. ç§»é™¤ç¸®æ”¾ (scale)
            const scaledX = translatedX / scale;
            const scaledY = translatedY / scale;
            
            // 3. ç§»é™¤ä¸–ç•Œå¹³ç§» (panX, panY)
            const worldX = scaledX - panX;
            const worldY = scaledY - panY;

            // æ¸¬è©¦æ¯å€‹åœ‹å®¶
            for (const country of countries) {
                // å¿…é ˆé‡æ–°å»ºç«‹è·¯å¾‘ï¼Œå› ç‚º isPointInPath ä¾è³´ç•¶å‰è·¯å¾‘
                ctx.beginPath();
                ctx.moveTo(country.startPoint.x, country.startPoint.y);
                country.curves.forEach(curve => {
                    const cp1 = curve[0];
                    const cp2 = curve[1];
                    const end = curve[2];
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                });
                ctx.closePath();

                // åŸ·è¡Œæ¸¬è©¦
                if (ctx.isPointInPath(worldX, worldY)) {
                    return country; // å‘½ä¸­
                }
            }
            return null; // æœªå‘½ä¸­ä»»ä½•åœ‹å®¶
        }

        // ----------------------------------------------------
        // é¸å–®èˆ‡é•·æŒ‰é‚è¼¯
        // ----------------------------------------------------

        /**
         * é¡¯ç¤ºä¸Šä¸‹æ–‡é¸å–®
         */
        function showContextMenu(clientX, clientY, country) {
            contextMenu.style.left = `${clientX}px`;
            contextMenu.style.top = `${clientY}px`;
            contextMenu.style.display = 'block';
            currentLongPressTarget = country;
            
            // æ›´æ–°é¸å–®é¸é …çš„é‚è¼¯ï¼ˆå¦‚æœå°‡ä¾†æœ‰å¤šå€‹é¸é …ï¼‰
            document.getElementById('countryStatusOption').innerText = `åœ‹å®¶æƒ…æ³ (${country.name})`;
        }
        
        /**
         * éš±è—ä¸Šä¸‹æ–‡é¸å–®
         */
        function hideContextMenu() {
            contextMenu.style.display = 'none';
            currentLongPressTarget = null;
        }

        // è™•ç†é¸å–®é¸é …çš„é»æ“Šäº‹ä»¶
        document.getElementById('countryStatusOption').addEventListener('click', () => {
            if (currentLongPressTarget) {
                alert(`æŸ¥çœ‹ ${currentLongPressTarget.name} çš„åœ‹å®¶æƒ…æ³ï¼`);
                hideContextMenu();
            }
        });
        
        // é»æ“Šä»»ä½•åœ°æ–¹éš±è—é¸å–®
        window.addEventListener('click', (e) => {
            // å¦‚æœé»æ“Šç›®æ¨™ä¸æ˜¯é¸å–®æœ¬èº«ï¼Œå‰‡éš±è—
            if (!contextMenu.contains(e.target) && e.target.id !== 'restartButton') {
                hideContextMenu();
            }
        });
        // ç¦ç”¨ç€è¦½å™¨é è¨­çš„å³éµé¸å–®
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());


        // ----------------------------------------------------
        // äº’å‹•é‚è¼¯ (ä¿®æ”¹ mousedown/touchstart å¯¦ç¾é•·æŒ‰)
        // ----------------------------------------------------
        
        function getDistance(touch1, touch2) {
            return Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) + 
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
        }
        
        function performZoom(clientX, clientY, newScale) {
            newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;
            scale = newScale;
            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;
            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);
            draw();
        }
        
        // --- æ ¸å¿ƒæ‹–æ›³/å¹³ç§»å‡½æ•¸ (æœªè®Š) ---
        function handleMove(clientX, clientY) {
            if (!isDragging || isPinching) return; 
            // å¦‚æœåœ¨æ‹–æ›³æ™‚ç§»å‹•è¶…éå¾ˆå°çš„è·é›¢ï¼Œå°±å–æ¶ˆé•·æŒ‰
            if (longPressTimer) {
                const distanceMoved = Math.sqrt(Math.pow(clientX - lastX, 2) + Math.pow(clientY - lastY, 2));
                if (distanceMoved > 5) { // å…è¨± 5px çš„å¾®å°ç§»å‹•
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }

            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            panX += deltaX / scale;
            panY += deltaY / scale;
            lastX = clientX;
            lastY = clientY;
            draw();
        }

        // --- æ ¸å¿ƒé–‹å§‹å‡½æ•¸ (æ–°å¢é•·æŒ‰é‚è¼¯) ---
        function handleStart(clientX, clientY) {
            hideContextMenu(); // é–‹å§‹ä»»ä½•æ“ä½œï¼Œå…ˆéš±è—é¸å–®
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            canvas.classList.add('grabbing');
            
            // å˜—è©¦è¨­ç½®é•·æŒ‰è¨ˆæ™‚å™¨
            const targetCountry = hitTestCountry(clientX, clientY);
            if (targetCountry) {
                longPressTimer = setTimeout(() => {
                    showContextMenu(clientX, clientY, targetCountry);
                    longPressTimer = null; // è§¸ç™¼å¾Œæ¸…é™¤è¨ˆæ™‚å™¨
                    isDragging = false; // é•·æŒ‰è§¸ç™¼å¾Œï¼Œé˜»æ­¢æ‹–æ›³ç¹¼çºŒ
                }, LONG_PRESS_DURATION);
            }
        }

        // --- æ ¸å¿ƒçµæŸå‡½æ•¸ (æ–°å¢é•·æŒ‰æ¸…é™¤é‚è¼¯) ---
        function handleEnd() {
            clearTimeout(longPressTimer); // æŠ¬èµ·æ™‚æ¸…é™¤è¨ˆæ™‚å™¨
            longPressTimer = null;
            isDragging = false;
            isPinching = false;
            lastTouchDistance = null;
            canvas.classList.remove('grabbing');
        }
        
        // ----------------------------------------------------
        // äº‹ä»¶ç›£è½
        // ----------------------------------------------------
        
        // æ»‘é¼ äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // æ»¾è¼ªç¸®æ”¾ (æœªè®Š)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            const delta = e.deltaY * -ZOOM_SPEED * 10; 
            const newScale = scale * (1 + delta);
            performZoom(e.clientX, e.clientY, newScale);
        });
        
        // è§¸æ§äº‹ä»¶ (ä¿®æ”¹ start/move å¯¦ç¾é•·æŒ‰/é›™æŒ‡åˆ¤æ–·)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1) {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                clearTimeout(longPressTimer); // é›™æŒ‡æ“ä½œæ™‚ç«‹å³æ¸…é™¤é•·æŒ‰
                longPressTimer = null;
                isPinching = true;
                handleEnd(); 
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                lastTouchDistance = getDistance(t1, t2);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length === 1 && !isPinching) {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                isPinching = true;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                const currentDistance = getDistance(t1, t2);
                const deltaDistance = currentDistance - lastTouchDistance;
                
                const touchCenter = { 
                    x: (t1.clientX + t2.clientX) / 2, 
                    y: (t1.clientY + t2.clientY) / 2 
                };
                
                const scaleFactor = deltaDistance * 0.005; 
                const newScale = scale + (scale * scaleFactor);

                performZoom(touchCenter.x, touchCenter.y, newScale);
                lastTouchDistance = currentDistance; 
            }
        });

        window.addEventListener('touchend', (e) => {
            handleEnd(); // çµæŸé•·æŒ‰è¨ˆæ™‚å™¨
            if (e.touches.length === 1) {
                // å¦‚æœåªå‰©ä¸€æ ¹æ‰‹æŒ‡ï¼Œç‚ºæ½›åœ¨çš„å–®æŒ‡æ‹–æ›³æº–å‚™
                isPinching = false;
                lastTouchDistance = null;
            }
        });
        window.addEventListener('touchcancel', handleEnd); 

        // ----------------------------------------------------
        // åˆå§‹åŒ–
        // ----------------------------------------------------
        resizeCanvas(); 
        generateNewCountries(); 
    </script>
</body>
</html>
