<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 地面操作與軸向消失 (優先取消選取)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        /* 軸向顏色提示 */
        #axis-legend {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
        .axis-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="axis-legend">
        軸向顏色:<br>
        <span class="axis-color" style="background-color: red;"></span>X 軸 (左右)<br>
        <span class="axis-color" style="background-color: green;"></span>Y 軸 (上下)<br>
        <span class="axis-color" style="background-color: blue;"></span>Z 軸 (前後)
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
        // --- 1. 場景初始化 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 設置光線
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // --- 2. 創建地面 (BoxGeometry 帶厚度) ---
        const groundWidth = 100;
        const groundHeight = 0.5; 
        const groundDepth = 100;
        
        const groundGeometry = new THREE.BoxGeometry(groundWidth, groundHeight, groundDepth);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.name = 'Ground';
        scene.add(ground);

        // 初始化相機位置
        camera.position.set(20, 10, 20);

        // --- 3. 設置控制器 ---
        
        // A. 空間旋轉控制器 (OrbitControls)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true; 
        
        // B. 變換控制器 (TransformControls)
        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setMode('translate'); // 移動模式
        transformControls.attach(ground);       
        scene.add(transformControls);
        
        // 預設隱藏並禁用
        transformControls.visible = false;
        transformControls.enabled = false;

        let isGroundSelected = false; // 地面是否被選中
        
        // 監聽 TransformControls 的拖曳事件：
        transformControls.addEventListener('dragging-changed', function (event) {
            // **只有在拖曳 Gizmo 軸向時，才暫時禁用 OrbitControls。**
            // 否則，保持 controls.enabled 狀態 (這保證了軸向顯示時，在非軸向區域可以旋轉)
            controls.enabled = !event.value;
        });
        
        // --- 4. 點擊選中與旋轉邏輯 ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function getNormalizedPointer(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        // 處理滑鼠/手指按下事件
        function onPointerDown(event) {
            getNormalizedPointer(event);
            raycaster.setFromCamera(pointer, camera);

            // 1. 如果 Gizmo 處於活動狀態，檢查是否點擊到 Gizmo 軸向
            if (isGroundSelected) {
                const intersectsGizmo = raycaster.intersectObjects(transformControls.children, true);
                
                if (intersectsGizmo.length > 0) {
                    // 點擊到 Gizmo 的軸，交由 TransformControls 處理
                    // controls.enabled 會在 dragging-changed 事件中被臨時禁用
                    return; 
                }
            }
            
            // 2. 檢查是否點擊到地面
            const intersectsGround = raycaster.intersectObjects([ground]);
            
            if (intersectsGround.length > 0 && intersectsGround[0].object.name === 'Ground') {
                // A. 點擊到地面 -> 選中地面
                
                if (!isGroundSelected) {
                    isGroundSelected = true;
                    
                    // 啟用並顯示軸向控制器
                    transformControls.visible = true;
                    transformControls.enabled = true;
                }
                
                // 軸向顯示時，保持 controls.enabled = true (允許旋轉)
                controls.enabled = true; 

            } else {
                // B. 點擊到非地面/非 Gizmo 軸區域
                
                if (isGroundSelected) {
                    // **核心修正：軸向顯示時，按下非 Gizmo/非地面區域，立即執行取消選取**
                    
                    // 軸向消失
                    transformControls.visible = false;
                    transformControls.enabled = false;
                    isGroundSelected = false; 
                    
                    // **重要：暫時禁用 OrbitControls** (確保這次操作是取消選取，而不是旋轉)
                    controls.enabled = false; 

                } else {
                    // 如果原本就沒有選中任何東西，則啟用空間旋轉
                    controls.enabled = true;
                }
            }
        }
        
        // 處理滑鼠/手指釋放事件
        function onPointerUp(event) {
            // 只有當物體未被選中且 Gizmo 未在拖曳時，才重新啟用 OrbitControls
            // 這恢復了「按下非地面取消選取後」的旋轉功能
            if (!isGroundSelected && !transformControls.dragging) {
                controls.enabled = true;
            }
        }

        // 監聽事件
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);

        // --- 5. 渲染迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); 
            transformControls.update(); 
            renderer.render(scene, camera);
        }

        animate();

        // --- 6. 響應式調整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
