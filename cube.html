<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 地面操作與空間旋轉 (共存旋轉與軸向消失)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        /* 軸向顏色提示 */
        #axis-legend {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
        .axis-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="axis-legend">
        軸向顏色:<br>
        <span class="axis-color" style="background-color: red;"></span>X 軸 (左右)<br>
        <span class="axis-color" style="background-color: green;"></span>Y 軸 (上下)<br>
        <span class="axis-color" style="background-color: blue;"></span>Z 軸 (前後)
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
        // --- 1. 場景初始化 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 設置光線
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // --- 2. 創建地面 (BoxGeometry 帶厚度) ---
        const groundWidth = 100;
        const groundHeight = 0.5; 
        const groundDepth = 100;
        
        const groundGeometry = new THREE.BoxGeometry(groundWidth, groundHeight, groundDepth);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.name = 'Ground';
        scene.add(ground);

        // 初始化相機位置
        camera.position.set(20, 10, 20);

        // --- 3. 設置控制器 ---
        
        // A. 空間旋轉控制器 (OrbitControls)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true; 
        
        // B. 變換控制器 (TransformControls)
        const transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.setMode('translate'); // 移動模式
        transformControls.attach(ground);       
        scene.add(transformControls);
        
        // 預設隱藏並禁用
        transformControls.visible = false;
        transformControls.enabled = false;

        let isGroundSelected = false; // 地面是否被選中
        
        // 監聽 TransformControls 的拖曳事件：確保在拖曳 Gizmo 時，空間旋轉被禁用
        transformControls.addEventListener('dragging-changed', function (event) {
            // 當 Gizmo 被拖曳時，禁用 OrbitControls，防止相機意外移動
            // 這是 Three.js 交互的標準做法
            controls.enabled = !event.value;
        });
        
        // --- 4. 點擊選中與旋轉邏輯 ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function getNormalizedPointer(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        // 處理滑鼠/手指按下事件
        function onPointerDown(event) {
            getNormalizedPointer(event);
            raycaster.setFromCamera(pointer, camera);

            // 1. 檢查是否點擊到 Gizmo 本身 (如果 Gizmo 處於活動狀態)
            if (isGroundSelected) {
                // 如果地面已被選中，檢查是否點擊到 Gizmo 軸
                const intersectsGizmo = raycaster.intersectObjects(transformControls.children, true);
                
                if (intersectsGizmo.length > 0) {
                    // 點擊到 Gizmo 的軸，交由 TransformControls 處理
                    // 這裡不需要做任何額外操作，TransformControls 的 'dragging-changed' 會處理 controls.enabled
                    return; 
                }
            }
            
            // 2. 檢查是否點擊到地面
            const intersectsGround = raycaster.intersectObjects([ground]);
            
            if (intersectsGround.length > 0 && intersectsGround[0].object.name === 'Ground') {
                // A. 點擊到地面 -> 選中地面
                
                // 只有當地面未被選中時才切換狀態，否則保持當前狀態
                if (!isGroundSelected) {
                    isGroundSelected = true;
                    
                    // 啟用並顯示軸向控制器
                    transformControls.visible = true;
                    transformControls.enabled = true;
                    
                    // 禁用空間旋轉，以防在點擊地面後立即拖曳時發生衝突
                    controls.enabled = false; 
                }
            } else {
                // B. 點擊到非地面區域 (滿足您的兩個要求)
                
                if (isGroundSelected) {
                    // **要求 1: 軸向要消失**
                    transformControls.visible = false;
                    transformControls.enabled = false;
                    isGroundSelected = false; 
                }
                
                // **要求 2: 要能旋轉空間**
                // 即使剛取消選中，也要立即啟用 OrbitControls，讓當前拖曳動作變成空間旋轉
                controls.enabled = true;
            }
        }
        
        // 處理滑鼠/手指釋放事件
        function onPointerUp(event) {
            // 僅在 Gizmo 拖曳停止後，且地面未被選中時，確保 OrbitControls 處於啟用狀態
            if (!isGroundSelected && !transformControls.dragging) {
                controls.enabled = true;
            }
            // 如果地面被選中，則保持 controls.enabled 狀態 (在 onPointerDown 中已設為 false)，直到下次點擊外部
        }

        // 監聽事件
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);

        // --- 5. 渲染迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); 
            transformControls.update(); 
            renderer.render(scene, camera);
        }

        animate();

        // --- 6. 響應式調整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
