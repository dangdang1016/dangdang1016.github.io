<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 地面拖曳與空間旋轉 (有厚度)</title>
    <style>
        body { margin: 0; overflow: hidden; } /* 移除邊距和捲軸 */
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- 1. 場景初始化 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 設置光線
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // --- 2. 創建地面 (使用 BoxGeometry 來創建帶有厚度的地面) ---
        const groundWidth = 100;
        const groundHeight = 0.5; // <-- 地面的厚度，設定為 0.5
        const groundDepth = 100;
        
        const groundGeometry = new THREE.BoxGeometry(groundWidth, groundHeight, groundDepth);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        
        // 確保地面中心位於世界座標的 Y=0 軸上，使其看起來是“坐在”地平線上
        ground.position.y = 0; // 當中心在 Y=0 時，厚度為 0.5 的地面將從 Y=-0.25 到 Y=0.25
        ground.name = 'Ground'; // 給地面命名以便於識別
        scene.add(ground);

        // 初始化相機位置
        camera.position.set(20, 10, 20);

        // --- 3. 實現空間旋轉 (使用 OrbitControls) ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.05;
        // 允許相機在水平上移動 (平移)，這樣拖曳地面時不會與相機控制衝突
        controls.screenSpacePanning = true; 

        // --- 4. 實現地面拖曳 ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDragging = false;
        let selectedObject = null;
        let plane = new THREE.Plane();
        let intersectPoint = new THREE.Vector3();
        let offset = new THREE.Vector3();
        
        // 由於地面現在是一個Box，拖曳平面應該是地面的頂部或底部所在的平面。
        const GROUND_Y_LEVEL = ground.position.y; 

        // 處理滑鼠/手指按下事件
        function onPointerDown(event) {
            event.preventDefault();

            // 獲取標準化裝置坐標 (從 -1 到 +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // 檢查是否點擊到地面
            const intersects = raycaster.intersectObjects([ground]);

            if (intersects.length > 0 && intersects[0].object.name === 'Ground') {
                // 點擊到地面
                isDragging = true;
                selectedObject = intersects[0].object;
                controls.enabled = false; // 禁用空間旋轉控制

                // 設置拖曳平面：以世界空間的 Y 軸為法線，經過地面的中心點
                plane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), selectedObject.position);
                
                // 計算射線與該拖曳平面的交點
                raycaster.ray.intersectPlane(plane, intersectPoint);
                
                // 計算滑鼠點擊位置與物體中心位置的偏移量 (用於精確拖曳)
                offset.copy(selectedObject.position).sub(intersectPoint);
            } else {
                // 沒有點擊到地面 (啟用空間旋轉)
                controls.enabled = true;
            }
        }

        // 處理滑鼠/手指移動事件
        function onPointerMove(event) {
            event.preventDefault();

            if (!isDragging || !selectedObject) return;

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // 獲取新的平面交點
            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                // 將地面移動到新的交點位置，並加上偏移量
                // 我們只更新 X 和 Z 軸，保持 Y 軸高度不變，確保地面只在水平方向移動
                selectedObject.position.x = intersectPoint.x + offset.x;
                selectedObject.position.z = intersectPoint.z + offset.z;
            }
        }

        // 處理滑鼠/手指釋放事件
        function onPointerUp(event) {
            if (isDragging) {
                isDragging = false;
                selectedObject = null;
            }
            controls.enabled = true;
        }
        
        // 確保同時支持滑鼠和觸摸
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        renderer.domElement.addEventListener('pointerleave', onPointerUp); // 滑鼠離開畫布也視為釋放

        // --- 5. 渲染迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            controls.update(); // 必須呼叫，以更新阻尼和旋轉狀態
            renderer.render(scene, camera);
        }

        animate();

        // --- 6. 響應式調整 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
