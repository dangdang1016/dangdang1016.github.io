<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>無邊際平面與不規則多國標記</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; /* 禁用瀏覽器預設的觸控行為，讓 Canvas 完全接管 */
        }
        #infiniteCanvas {
            display: block;
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>

    <script>
        // ----------------------------------------------------
        // 主要變數
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');

        // 畫布的狀態
        let panX = 0; 
        let panY = 0; 
        let scale = 1.0; 
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; 

        // 互動狀態變數
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        // 網格設定
        const BASE_GRID_SIZE = 50; 
        
        // 國家標記數據 (使用頂點定義不規則多邊形，座標為世界座標系)
        const countries = [
            { 
                name: "國家 A (藍)", 
                color: "#007BFF", // 藍色
                center: {x: -150, y: -100}, // 文字中心點
                // 頂點座標 (相對於世界座標原點)
                shape: [
                    {x: -250, y: -180},
                    {x: -100, y: -200},
                    {x: -50, y: -80},
                    {x: -200, y: 0},
                    {x: -300, y: -50}
                ]
            },
            { 
                name: "國家 B (紅)", 
                color: "#DC3545", // 紅色
                center: {x: 50, y: 50},
                shape: [
                    {x: 0, y: 0},
                    {x: 200, y: 50},
                    {x: 100, y: 200},
                    {x: 0, y: 150},
                    {x: -50, y: 100}
                ]
            },      
            { 
                name: "國家 C (黃)", 
                color: "#FFC107", // 黃色
                center: {x: -200, y: 200},
                shape: [
                    {x: -300, y: 300},
                    {x: -150, y: 350},
                    {x: -50, y: 250},
                    {x: -200, y: 100},
                    {x: -350, y: 150}
                ]
            }     
        ];

        // ----------------------------------------------------
        // 初始化與互動函數 (保持與前次版本相同)
        // ----------------------------------------------------

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); 

        function handleMove(clientX, clientY) {
            if (!isDragging) return;
            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;
            panX += deltaX / scale;
            panY += deltaY / scale;
            lastX = clientX;
            lastY = clientY;
            draw();
        }

        function handleStart(clientX, clientY) {
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            canvas.classList.add('grabbing');
        }

        function handleEnd() {
            isDragging = false;
            canvas.classList.remove('grabbing');
        }
        
        // 滑鼠事件
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);

        // 觸控事件
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault(); 
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                e.preventDefault(); 
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        window.addEventListener('touchend', handleEnd);
        window.addEventListener('touchcancel', handleEnd); 

        // 滾輪事件
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            const delta = e.deltaY * -ZOOM_SPEED;
            const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * (1 + delta)));

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;

            scale = newScale;

            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;

            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);

            draw();
        });


        // ----------------------------------------------------
        // 繪圖邏輯
        // ----------------------------------------------------

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // 應用變換矩陣：中心平移 -> 縮放 -> 世界平移
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            drawGrid();
            drawCountries(); // <-- 繪製不規則國家標記

            ctx.restore();
        }

        /**
         * 繪製不規則多邊形國家
         */
        function drawCountries() {
            countries.forEach(country => {
                const shape = country.shape;
                if (shape.length < 2) return;

                ctx.fillStyle = country.color;
                ctx.beginPath();
                
                // 1. 移動到第一個點
                ctx.moveTo(shape[0].x, shape[0].y);
                
                // 2. 連接到後續所有點
                for (let i = 1; i < shape.length; i++) {
                    ctx.lineTo(shape[i].x, shape[i].y);
                }
                
                // 3. 閉合路徑並填充
                ctx.closePath();
                ctx.fill();
                
                // 繪製邊框 (可選，讓形狀更清晰)
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3 / scale; // 線寬隨縮放調整
                ctx.stroke();

                
                // 繪製國家名稱
                ctx.font = `${20 / scale}px Arial`;
                // 根據背景色選擇文字顏色
                ctx.fillStyle = (country.color === "#FFC107") ? "#000000" : "#ffffff"; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 使用預定義的中心點 (center) 來放置文字
                ctx.fillText(country.name, country.center.x, country.center.y);
            });
        }


        function drawGrid() {
            let gridSize = BASE_GRID_SIZE;
            
            while (gridSize * scale < 20) {
                gridSize *= 5; 
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; 
            }

            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; 

            ctx.beginPath();

            // 繪製垂直線
            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            // 繪製水平線
            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            // 繪製主要網格
            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
    </script>
</body>
</html>
