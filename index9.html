<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>支援觸控的無邊際平面</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #f0f0f0;
            touch-action: none; /* 禁用瀏覽器預設的觸控行為，讓 Canvas 完全接管 */
        }
        #infiniteCanvas {
            display: block;
            /* 桌面版游標 */
            cursor: grab; 
        }
        #infiniteCanvas.grabbing {
            cursor: grabbing;
        }
    </style>
</head>
<body>

    <canvas id="infiniteCanvas"></canvas>

    <script>
        // ----------------------------------------------------
        // 主要變數
        // ----------------------------------------------------
        const canvas = document.getElementById('infiniteCanvas');
        const ctx = canvas.getContext('2d');

        // 畫布的狀態：平移偏移量和縮放比例
        let panX = 0; // X 軸平移偏移量 (世界座標)
        let panY = 0; // Y 軸平移偏移量 (世界座標)
        let scale = 1.0; // 縮放比例
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 5.0;
        const ZOOM_SPEED = 0.001; // 滾輪縮放速度

        // 互動狀態變數
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        // 網格設定
        const BASE_GRID_SIZE = 50; // 基礎網格單元大小 (世界座標單位)

        // ----------------------------------------------------
        // 初始化與公用函數
        // ----------------------------------------------------

        // 調整畫布大小以填滿視窗
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // 初始呼叫

        /**
         * 處理平移 (拖曳或單指觸控)
         * @param {number} clientX - 當前的 X 螢幕座標
         * @param {number} clientY - 當前的 Y 螢幕座標
         */
        function handleMove(clientX, clientY) {
            if (!isDragging) return;

            // 計算螢幕上的像素移動距離
            const deltaX = clientX - lastX;
            const deltaY = clientY - lastY;

            // 將像素距離轉換為世界座標距離 (需要考慮縮放)
            panX += deltaX / scale;
            panY += deltaY / scale;

            lastX = clientX;
            lastY = clientY;

            draw();
        }

        /**
         * 處理開始拖曳 (滑鼠按下或單指觸控開始)
         * @param {number} clientX - X 螢幕座標
         * @param {number} clientY - Y 螢幕座標
         */
        function handleStart(clientX, clientY) {
            isDragging = true;
            lastX = clientX;
            lastY = clientY;
            canvas.classList.add('grabbing');
        }

        /**
         * 處理結束拖曳
         */
        function handleEnd() {
            isDragging = false;
            canvas.classList.remove('grabbing');
        }
        
        // ----------------------------------------------------
        // 1. 滑鼠事件 (用於桌面)
        // ----------------------------------------------------
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);


        // ----------------------------------------------------
        // 2. 觸控事件 (用於行動裝置)
        // ----------------------------------------------------
        canvas.addEventListener('touchstart', (e) => {
            // 只需要處理單指觸控 (拖曳/平移)
            if (e.touches.length === 1) {
                e.preventDefault(); // 阻止預設行為 (例如螢幕捲動)
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            // 只需要處理單指觸控 (拖曳/平移)
            if (e.touches.length === 1) {
                e.preventDefault(); 
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        });

        window.addEventListener('touchend', handleEnd);
        window.addEventListener('touchcancel', handleEnd); // 處理觸控意外中斷


        // ----------------------------------------------------
        // 3. 滾輪事件 (用於縮放)
        // ----------------------------------------------------
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); 

            // 計算縮放因子
            const delta = e.deltaY * -ZOOM_SPEED;
            const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * (1 + delta)));

            // 縮放中心點 (以滑鼠位置為中心) 
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // 1. 取得縮放前，滑鼠點對應的世界座標
            const worldXBefore = (mouseX - canvas.width / 2) / scale - panX;
            const worldYBefore = (mouseY - canvas.height / 2) / scale - panY;

            // 2. 更新縮放比例
            scale = newScale;

            // 3. 取得縮放後，滑鼠點對應的世界座標
            const worldXAfter = (mouseX - canvas.width / 2) / scale - panX;
            const worldYAfter = (mouseY - canvas.height / 2) / scale - panY;

            // 4. 計算平移量補償
            panX += (worldXAfter - worldXBefore);
            panY += (worldYAfter - worldYBefore);

            draw();
        });


        // ----------------------------------------------------
        // 繪圖邏輯 (與前次版本相同，專注於繪製動態網格)
        // ----------------------------------------------------

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // 應用變換矩陣：中心平移 -> 縮放 -> 世界平移
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(panX, panY);

            drawGrid();

            ctx.restore();
        }

        function drawGrid() {
            // 動態調整網格大小
            let gridSize = BASE_GRID_SIZE;
            while (gridSize * scale < 20) {
                gridSize *= 5; 
            }
            while (gridSize * scale > 100) {
                gridSize /= 5; 
            }

            // 計算畫布可視範圍在世界座標中的邊界
            const startX = (-canvas.width / 2 / scale) - panX;
            const startY = (-canvas.height / 2 / scale) - panY;
            const endX = (canvas.width / 2 / scale) - panX;
            const endY = (canvas.height / 2 / scale) - panY;
            
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1 / scale; 

            ctx.beginPath();

            // 繪製垂直線
            let firstX = Math.floor(startX / gridSize) * gridSize;
            for (let x = firstX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }

            // 繪製水平線
            let firstY = Math.floor(startY / gridSize) * gridSize;
            for (let y = firstY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }

            ctx.stroke();

            // 繪製主要網格 (較深的顏色)
            if (gridSize * 5 * scale > 20) {
                const majorGridSize = gridSize * 5;
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 2 / scale;

                ctx.beginPath();

                let firstMajorX = Math.floor(startX / majorGridSize) * majorGridSize;
                for (let x = firstMajorX; x < endX; x += majorGridSize) {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }

                let firstMajorY = Math.floor(startY / majorGridSize) * majorGridSize;
                for (let y = firstMajorY; y < endY; y += majorGridSize) {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }

                ctx.stroke();
            }
        }
    </script>
</body>
</html>
